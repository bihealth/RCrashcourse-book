# Day 1: Introduction to R

## Goals for today

 * what is R?
 * why use R?
 * first steps in R

What you should know after today:

 * what R is
 * how to start R
 * how to use R as a calculator
 * how to assign variables
 * how to use functions
 * how to use vectors
 * how to use data frames
 * how to use packages

## R, RStudio and other languages

### Why R?

### R and RStudio

R is the name of both, the programming language and of the language
*interpreter*. When you start RStudio, you can see the R language
interpreter working in the part of the window left and bottom - called
"console". So yes, you don't need RStudio to work with R and, in fact, many
people prefer to work with R in a different environment.

RStudio is a so called IDE, an Integrated Development Environment. That is,
it provides a lot of goodies that help make your work easier, faster and
more efficient.

### R and other languages

R is not the only language that you can use for data analysis. There are
many other languages that are used for this purpose, including Python,
Matlab and many others. Each of these languages has its own strengths and
weaknesses, and the choice of language depends on your needs. In fact, most
bioinformaticians know more than one language, and use the one that is best
suited for the task at hand.

We think that R is a particularly good choice for all those who just need a
tool to use from time to time to help them with their work. It is
relatively easy to learn, and it is very powerful. However, other choices
are also worth mentioning.

**Matlab** is a language that is in many ways similar to R. The main
differnce is maybe that unlike R, Matlab is not free – it is closed source
and you have to pay for a license. This has some advantages. For example,
and as you will see during this course, R development is not centralized
and so there are many packages that do the same thing. Matlab is in some
aspects more consistent and more polished than R, and in some comparisons
appears to be faster – and for this, it is often the language of choice for
areas such as image analysis.

**Python** is completely different story. This is a powerful, fast, general
purpose programming language. It is more versatile than R, has a much more
standardized syntax and development process. However, it is harder to learn
and it is not really meant to be used interactively (although it can be –
especially when combined with Quarto or Jupyter Notebook). While many
statistical modules exist for Python, it is not as strong in this area as
R.

## Projects and Workspaces

### Creating a project: start here!

When starting work with a new project, do the following: (i) create a new
directory for the project, (ii) open an R script file and save it in the
directory you created and (iii) copy necessary data files.

To create a new directory in RStudio, go to File -> New Project. When the
dialog window appears, select first "New Directory" and then "New Project".
Select the location where you would like to have the directory created and 
click on "Create Project".

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-create}
 * Create a new project in RStudio. Do it now, you will continue to work with
this project over the next few days (we hope).
 * Inspect the contents of the project directory. What files are there?
:::
:::


When Rstudio creates a new project, it creates a new directory with the same
name as the project. Furthermore, it creates a new file in this directory
called `projectname.Rproj`. This file is used by RStudio to keep track of
project-specific settings.

You can open this file by double-clicking on it in the Files pane in
RStudio. Like most of the files that you will be working with, it is a
simple text file: you can open it in any text editor, including RStudio.

Later on, if you choose to do so, R can create two hidden files, `Rhistory`
(called `.Rhistory` on Unix-like systems and `_Rhistory` on Windows) and `.RData` (or `_RData`). 
This files save the state of your R session (of your R workspace, to be
specific).

### Workspaces, history and environments

## Let's start with R

### R as a calculator

You can use R as a very powerful calculator. For example, do you want to
know what $\sin(\pi/2)$ is? Just type `sin(pi/2)` in the console and press
`Enter`. Addition and subtraction work, as expected, with `+` and `-`. To
multiply two numbers, type `2*3`; to divide, type `2/3`. You can get
exponents (powers, eg. $2^3$) by typing `2^3`. If the `^` symbol (called
"caret") is not available on your keyboard, you can use `**` instead.
Parentheses `()` are used to group expressions, just like in mathematics.
To logarithmize, you can use `log()`, `log2()` and `log10()` functions. For
example, to calculate $\log_{10}(100)$, type `log10(100)`. Can you guess
how to calculate $\sqrt{2}$? Yes, you are right: `sqrt(2)`. Or `2^(1/2)`,
that will also do.

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-calc}

Calculate the following expressions in R:

 * $\log_{2}(8)$
 * $\sin(\pi)$
 * $2^{10}$
 * $\sqrt{e}$

:::
:::

### Using script files

On the left side of the RStudio window you have (by default) two panels:
the lower one is called "Console". When you create a new script file, it
appears above.

::: {.callout-tip}
## Typing in console

You *can* type your commands (properly called "expressions") directly into
the console, but it is generally not a good idea. Why? The truthful answer
is: because it is messy and sooner or later you will regret it. You *can*
save the history of what you type in the console, but it is easier (and
cleaner) to save your program in a script file.
:::

When you open or create an R script file and type something into it, you
can run it by pressing `Ctrl+Enter` (or `Cmd+Enter` on Mac). This will send
the line of code to the console, where it will be executed.
You can also **select** a fragment of the code before you press
`Ctrl+Enter`, and then the whole selected fragment will be sent to the
console.

However, if you start your line with `#`, it will not be executed. This is
called a **comment** and we will spend some time later on convincing you
that you should use a lot of comments in your code.

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-script}

Repeat @exr-calc, but now type the expressions into the script which you
have created in @exr-create. Run the script by pressing `Ctrl+Enter` after
each line.

:::
:::

Script files are also text documents. You can open them in any text editor,
for example Notepad or even Word (but don't do that). In RStudio, you see
the script file in many colors: for example, comments can be green, strings
(text in quotes) can be red, and so on. This is called **syntax
highlighting** and is done by RStudio to make your code more readable. You
will not see the colors when you open your R script in Notepad.

::: {.callout-important}
From now on, you should only type your code in script files.
:::

### Variables

What if we want to store the result of a calculation for later use? We can
do this by assigning the result to a variable. In R, you assign a value to a
variable using the `<-` operator: 


```{r}
x <- 2
y <- sin(pi/2)
z <- x + y
```

If you want to see the value of a variable, just type its name in the
console and press `Enter`, or use `print()` function:


```{r}
print(z)
```


::: {.callout-tip}
## Assignment operator

Many other languages use `=` as an assignment operator. In R, you can use
`=` as well, but do yourself a favour and **don't**. Use `<-` instead. Why?
Your code will be more readable and you will avoid many common mistakes.
:::

Variables are like boxes in which you can store values. However, unlike
boxes, when you assign one variable to another, the first variable keeps
its content:


```{r}
x <- 2
y <- x
print(x)
```

We now come to a very important point which we will revisit often, as it is
one of the most common beginner (and not only beginner) mistakes. When you
forget to assign the value to a variable, R will print it to the console,
but the variable **will not be modified**:


```{r results=FALSE}
x <- 2
# prints 0.9092974:
sin(x) 
# prints 2
print(x) 
```

In the code above, the value of `x` is not changed by the `sin()` function.
**To store the value of a function, you need to assign it to a variable**:

```{r results=FALSE}
x <- 2
# does not print anything:
x <- sin(x) 
# prints 0.9092974:
print(x)    
```

Please spend some time on this, as it is a very common source of errors.

::: {.callout-important}
As a rule of thumb[^exceptions], if the expression you type in your script
does not contain the `<-` operator, it will not modify any variables.
:::

[^exceptions]: There are exceptions to this rule, but they are relatively rare and
we will not discuss them here.


### Character variables

Variables can store not only numbers, but also text. Text in R is called a
**character string**. To create a character string, you need to enclose the
text in quotes (both single and double quotes are allowed, but try to be
consistent and use only one type). For example:


```{r}
name <- "January"
city <- "Hoppegarten"
greeting <- "Hello, world!"
```

Character variables cannot be used with algebraic computations, the
following code will throw an error:


```{r eval=FALSE}
# this does not work!
name + city
```

However, if you want to "add" two character strings (that is, concatenate
them), you can use the `paste()` function:


```{r}
paste(name, city)
```

Quite often, you don't want to have a space between the two strings. This
is such a common operation that R has a shortcut for it:


```{r}
paste0(name, city)
```


::: {.callout-tip}
## Other types

There are other types of data types in R. Later on, we will briefly touch on
*factors*, which look like character strings but behave like numbers.
And under the hood, numeric vectors can be either integers (numbers like 1,
2, ...) or floating point numbers (numbers like 1.1, 2.2 or $\pi$).
:::

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-variables}
## Variables

Create the following variables in your script:

 * `name` with the value of your first name
 * `city` with the value of the city where you live
 * `age` with the value of your age
 * `greeting` with the value "Hello,"
 * concatenate the variables `greeting` and `name` and store the
   result in a new variable `message`
:::
:::

### Vectors and vectorization

Variables can (and do) store a lot more than single values. One of the most
basic and important data types in R is a **vector**. A vector is simply a
sequence of values – just like in maths. And you know what? You have
already created vectors in R.
In mathematics,
any scalar value can be treated as a one-dimensional vector and it is
exactly like that in R: any single value is a 1-element vector, including
all the variables that you have created in the previous exercise.

To create a vector with more than one value, you can use the `c()` function
("c" stands for "combine"). For integer numbers, you can use the `:` operator
to create a sequence of numbers.
For example:


```{r}
sequence <- 5:15
numbers <- c(10, 42, 33, 14, 25)
person <- c("January", "Weiner", "Hoppegarten")
```

You can access individual elements of a vector using the `[ ]` operator:


```{r}
numbers[1]
person[2]
```

But hey, I told you that every value is a vector in R, right? And that
includes the indices `1` and `2` that you have just used. So, what would
happen if we used more than two values as an index? Try it:


```{r}
numbers[1:3]
person[3:1]
sel <- c(1, 5, 3)
numbers[sel]
```

As you can see, not only can you use a vector as an index, but you can also
use a *variable* as an index. 


::: {.callout-tip}
## Vectors and indices

In many (most?) programming languages, the first element of a vector is
accessed using the index 0. For example in Python, to access the firs
element of an array, you need to type `array[0]`. This has something to do
with how computers work. In R, the first element
is always `1` – R was designed by statisticians, and in mathematics we
always start counting from 1. For some reason, this seems to make some computer
scientists angry.
:::

But wait, there is more. What happens if we add a value to a vector? Try it:


```{r}
numbers <- c(10, 42, 33, 14, 25)
numbers + 10
```

As you can see, R has added the value 10 to every single element of the
vector `numbers`. The same thing happens with other operators, like `-`,
`*` and `/`. Try it yourself.

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-vectorisation}
## Vectorisation

 * Create a vector with several numbers and try to add, subtract, multiply and
   divide it by a single number. What happens?
 * Say, you have three values which are the diameters of three circles: 1,
   5 and 13. You would like to have a vector containing the areas of these
   circles. What is the simplest way of doing that?
:::
:::

This is called **vectorization** and it is one of the most powerful features
of R compared to other languages. It will allow you to write very concise
and, at the same time, readable code.

However, there is a catch. What happens if you try to add two vectors when
both of them with more than one element? First, let us try to add two
vectors of the same length:


```{r}
numbers1 <- c(1, 2, 3)
numbers2 <- c(4, 5, 6)
numbers1 + numbers2
```

As you can see, R has added the first element of the first vector to the
first element of the second vector, the second element of the first vector
to the second element of the second vector, and so on. Makes sense, right?
Same would happen if we were to subtract, multiply or divide the vectors
(or use logical operations, which you will learn on Day 3).
This does not look like much now, but trust me, it will be extremely useful
in the future.

However, if the vectors have *different* lengths, it is a different story
altogher. Take a look:


```{r}
numbers1 <- c(1, 2, 3)
numbers2 <- c(4, 5)
numbers1 + numbers2
```

Ooops, what exactly happened here? First thing to note is that *there was
no error*. There was a *warning*, but still our code executed and produced
a result. But what is that result? For the first element of the result, it
is clear enough: `1 + 4 = 5`. Same for the second, `2 + 5 = 7`. But what
about the third? It seems that R added `3 + 4 = 7`. But why?

R noticed that it is missing an element to be added to the third element of
the vector `numbers1`. So, it did what is called **recycling**. It
"rewound" the vector `numbers2` to the beginning and added the first
element of `numbers2` to the third element of `numbers1`. However, since
after the rewinding and adding one element of vector `numbers2` was left
(because `numbers1` did not have any more elements), R issued a warning. If
the length of the first vector was a multiple of the length of the second
vector, R would not have complained:


```{r}
numbers1 <- c(1, 2, 3, 4, 5, 6)
numbers2 <- c(7, 8)
numbers1 + numbers2
```

See? No warning. R was recycling the second vector over and over again.
Recycling is a dangerous business: if you are not careful, you can get
results which you have not expected.

::: {.callout-tip}
## Recycling advice

Here is our advice to you: either use a vector and a single element vector, or two 
vectors of the same length. And in the cases where, for some reason, you
need to recycle, make sure that you know what you are doing. For example,
check the length of both vectors.
:::


With vectors that have only a couple of numbers it is quite easy to see
what is happening, but what if you have thousands of variables? In other
words, how to check the lenght of a vector? You can use the `length()`:


```{r}
length(numbers1)
length(numbers2)
```

OK, one more thing about vectors. Above we have selected elements from a
vector. It turns out, we can do more with that selections then just print
it to a console:


```{r}
numbers <- c(10, 42, 33, 14, 25)
sel <- c(1, 5)
numbers[sel] <- c(100, 500)
numbers
```

Here is what happened: we assigned new values to the first and the fifth
element of the vector `numbers`. This is a very powerful feature of R and
you will be using it a lot.


### Water lillies on a lake

There is an old puzzle that goes: "On a lake, there is a water lily. Each
day the lily doubles in size. After 30 days, the lily covers the entire
lake. On which day was the lily covering half of the lake?".

In the following section we will model the behavior of the lily using R.
Let us start with some assumptions. First: we designate the first day as
Day 1. Second: every day, the lily doubles the area it covers. Third: on
the first day, the lily covers 1% of the lake.

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-lilies}
## Modelling water lilies

Take a piece of paper and a pen. Your task is to come up with a formula to
describe the area of the lily on the $n$-th day. Write down the formula.

Hint: if you are stuck, try to calculate the area of the lily on the first
few days.
:::
:::

There is an important point that we wish to demonstrate here. Quite often
it pays off to close your laptop and *think* for a moment what it is it
that you want to do, rather than start coding right away. Pen and paper are
helpful (we will be making this point again when it comes to
visualizations). If you do not have a clear idea of *what* you want to do,
you can get stuck thinking about what you already know how to do. 

The formula for calculating the area of the lily on the $n$-th day is
$0.01 \times 2^{n-1}$. You can come up with that result quite easily if you
consider the first few days. On day 1, the area is $1\% = 0.01$. On day 2, is twice
that, that is, $0.01 \times 2 = 0.01 \times 2^1 = 0.02$. On day 3, it is
twice the area from the previous day: $0.02 \times 2 = 0.04 = 0.01 \times 2
\times 2 = 0.01 \times 2^2$. And again, on day 4, it is $0.01 \times 2^3$.
And so on[^formula].

[^formula]: If started counting from 0 – that is, if we designated the
first day as Day 0 – the formula would be $0.01 \times 2^n$.

Once we have the formula, it is very easy to calculate the area covered by
water lillies on the first 10 days. We will use vectorization to do this:


```{r}
days <- 1:10
area <- 0.01 * 2^(days - 1)
area
```

This calls out for a plot. We will talk about visualizations more extensively
on Day 5, but for now, we will use a very basic and simple function to plot
the area of the lily on the first 30 days. The function is called `plot()`
and can be used to plot a graph of two vectors. The first vector is the
days, the second vector is the area.


```{r}
plot(days, area, type="b")
```

O-K, days and area are clear, but what is this `type="b"`? This is a
so-called *named* argument[^argument]. The `plot()` function has many arguments, and
if you want to use only some of them, you can use their names with an equal
sign. You will see that a lot in the days to come. This particular
argument, `type`, tells R what kind of plot to draw. The `"b"` stands for
"both" and tells R to draw both points and lines. If you want only points,
you can use `"p"` (or simple leave the argument out), if you want only
lines, you can use `"l"`.

[^argument]: Full disclosure: all arguments can be named in R. However,
some of the arguments have a default value, so we do not have to specify
them unless we need them. The `type` argument is one of them. Others must
always be specified. We will talk about this in more detail later.

Note another thing on this plot: after day 7, the area is greater than 1.
But 1 means 100%, so after day 7, the lily covers more than the entire
lake. Obviously, this is not possible – and it shows a limitation of our
model.

## Coding practices

### Computer programs as means for communication

It is now time to conclude today's lesson with a bit of philosophy. When
you write an R script, the first goal you have in mind is to analyse your
data – in other words, by means of what you write you are trying the
computer to do something for you. That is correct and fine, but there is
an important aspect of programming that is often overlooked.

When you write a program, you are writing it not only for the computer, but
also for other people. These other people may include your colleagues,
readers of your scientific articles, your students, and, last but not
least, a future version of yourself. All these people need more then just
a piece of code that works. You will quickly find it out yourself when you
open a script or a project that you have not been working on for a few
months – trust me on this, you will not know what it does, how it does and
sometimes even whether you have written it or copied from somewhere.

You might be thinking that you are never willing to show your code to
another person. You are wrong, and not only because it is useful *to you*
for another person to review your code. Firstly, you will *want* to share
your code because as a scientist you will want to share your results, and
results are nothing if the methods to obtain them are unknown. And
secondly, you will *need* to share your code because you will be asked to
do so by your colleagues (yes, I was as surprised as you will be when I was
asked to share my code for the first time). And thirdly, your code is part
of your methods and you will *have* to share it when you publish your
results[^publish].

[^publish]: Top journals already require that you share your code when you
publish your results. This will become more and more common in the future.

For communication with another human being to be efficient, you need to
make it as clear as possible. There are several ways how to make your code
more readable and understandable. Here are some of them.

**Comments**. Comments are lines in your code that are not executed. In R,
they start with a `#` sign. Comments help to explain what exactly are you
trying to achieve with your code. The old saying goes: "Code tells you how,
comments tell you why". You can hardly overdo with comments, but you can
easily underdo.

**Naming**. The names of your variables, functions and files should be
meaningful. If you have a variable that stores the number of days, call it
`days`, not `x`. If you have a function that calculates the area of a
circle, call it `calculate_circle_area()`, not `f()`. If you have a comma
separated values (CSV) file that contains the CRP values, call it
`crp_values.csv`, not `data.txt`.

**Formatting**. Your code should be formatted in a consistent way. For
example, you should always put a space around your operators, like `x <- 2`
(and not `x<-2`), you should always put a space after a comma, like
`c(1, 2)` and not `c(1,2)` (and also not `c( 1 , 2 )`). 
See [here](http://web.stanford.edu/class/cs109l/unrestricted/resources/google-style.html)
for a more detailed guide on how to format your code.


