# Introduction to R


```{r echo=FALSE}
options(width=80)

```





## Goals for today

 * what is R?
 * why use R?
 * first steps in R

What you should know after today:

 * what R is
 * how to start R
 * how to use R as a calculator
 * how to assign variables
 * how to use functions
 * how to use vectors
 * how to use data frames
 * how to use packages

## R, RStudio and other languages

### Why R?

### R and RStudio

R is the name of both, the programming language and of the language
*interpreter*. When you start RStudio, you can see the R language
interpreter working in the part of the window left and bottom - called
"console". So yes, you don't need RStudio to work with R and, in fact, many
people prefer to work with R in a different environment.

RStudio is a so called IDE, an Integrated Development Environment. That is,
it provides a lot of goodies that help make your work easier, faster and
more efficient.

### R and other languages

R is not the only language that you can use for data analysis. There are
many other languages that are used for this purpose, including Python,
Matlab and many others. Each of these languages has its own strengths and
weaknesses, and the choice of language depends on your needs. In fact, most
bioinformaticians know more than one language, and use the one that is best
suited for the task at hand.

We think that R is a particularly good choice for all those who just need a
tool to use from time to time to help them with their work. It is
relatively easy to learn, and it is very powerful. However, other choices
are also worth mentioning.

**Matlab** is a language that is in many ways similar to R. The main
[Matlab]{.aside}
differnce is maybe that unlike R, Matlab is not free – it is closed source
and you have to pay for a license. This has some advantages. For example,
and as you will see during this course, R development is not centralized
and so there are many packages that do the same thing. Matlab is in some
aspects more consistent and more polished than R, and in some comparisons
appears to be faster – and for this, it is often the language of choice for
areas such as image analysis.

**Python** is completely different story. This is a powerful, fast, general
[Python]{.aside}
purpose programming language. It is more versatile than R, has a much more
standardized syntax and development process. However, it is harder to learn
and it is not really meant to be used interactively (although it can be –
especially when combined with Quarto or Jupyter Notebook). While many
statistical modules exist for Python, it is not as strong in this area as
R.

## Projects and Workspaces

### Creating a project: start here!

When starting work with a new project, do the following: (i) create a new
[RStudio projects]{.aside}
directory for the project, (ii) open an R script file and save it in the
directory you created and (iii) copy necessary data files.

To create a new directory in RStudio, go to File -> New Project. When the
dialog window appears, select first "New Directory" and then "New Project".
Select the location where you would like to have the directory created and 
click on "Create Project".

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-create}
 * Create a new project in RStudio. Do it now, you will continue to work with
this project over the next few days (we hope).
 * Inspect the contents of the project directory. What files are there?
:::
:::


When Rstudio creates a new project, it creates a new directory with the same
name as the project. Furthermore, it creates a new file in this directory
called `projectname.Rproj`. This file is used by RStudio to keep track of
[`projectname.Rproj`]{.aside}
project-specific settings.

You can open this file by double-clicking on it in the Files pane in
RStudio. Like most of the files that you will be working with, it is a
simple text file: you can open it in any text editor, including RStudio.

The other file I told you to create is a *script* file. This is where you
will later be typing your code, and we will discuss it in more detail in a
moment.

Later on, if you choose to do so, R can create two hidden files, `Rhistory`
[`.Rhistory` and `.RData`]{.aside}
(called `.Rhistory` on Unix-like systems and `_Rhistory` on Windows) and `.RData` (or `_RData`). 
This files save the state of your R session (of your R workspace, to be
specific).

## Let's start with R

### R as a calculator

You can use R as a very powerful calculator. For example, do you want to
know what $\sin(\pi/2)$ is? Just type `sin(pi/2)` in the console and press
[`sin()`]{.aside}
`Enter`. Addition and subtraction work, as expected, with `+` and `-`. To
multiply two numbers, type `2*3`; to divide, type `2/3`. You can get
exponents (powers, eg. $2^3$) by typing `2^3`. If the `^` symbol (called
"caret") is not available on your keyboard, you can use `**` instead.
Parentheses `()` are used to group expressions, just like in mathematics.
To logarithmize, you can use `log()`, `log2()` and `log10()` functions. For
[`log()`, `log2()` and `log10()`]{.aside}
example, to calculate $\log_{10}(100)$, type `log10(100)`. Can you guess
how to calculate $\sqrt{2}$? Yes, you are right: `sqrt(2)`. Or `2^(1/2)`,
[`sqrt()`]{.aside}
that will also do. Finally, the `exp()` function calculates the exponential function
$e^x$.
[`exp()`]{.aside}

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-calc}

Calculate the following expressions in R:

 * $\log_{2}(8)$
 * $\sin(\pi)$
 * $2^{10}$
 * $\sqrt{e}$

::: {.callout-caution icon=false collapse=true}
## Solution


```{r}
log2(8)
sin(pi)
2^10
sqrt(exp(1))
```
:::



:::
:::

### Using script files

On the left side of the RStudio window you have (by default) two panels:
the lower one is called "Console". When you create a new script file, as
you have done it a moment ago, it appears above.

::: {.callout-tip}
## Typing in console

You *can* type your commands (properly called "expressions") directly into
the console, but it is generally not a good idea. Why? The truthful answer
is: because it is messy and sooner or later you will regret it. You *can*
save the history of what you type in the console, but it is easier (and
cleaner) to save your program in a script file.
:::

When you open or create an R script file and type something into it, you
can run it by pressing `Ctrl+Enter` (or `Cmd+Enter` on Mac). This will send
the line of code to the console, where it will be executed.
You can also **select** a fragment of the code before you press
`Ctrl+Enter`, and then the whole selected fragment will be sent to the
console.

However, if you start your line with `#`, it will not be executed. This is
called a **comment** and we will spend some time later on convincing you
that you should use a lot of comments in your code.

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-script}

Repeat @exr-calc, but now type the expressions into the script which you
have created in @exr-create. Run the script by pressing `Ctrl+Enter` after
each line.

:::
:::

Script files are also text documents. You can open them in any text editor,
for example Notepad or even Word (but don't do that). In RStudio, you see
the script file in many colors: for example, comments can be green, strings
(text in quotes) can be red, and so on. This is called **syntax
highlighting** and is done by RStudio to make your code more readable. You
will not see the colors when you open your R script in Notepad.

::: {.callout-important}
From now on, you should only type your code in script files.
:::

### Variables

What if we want to store the result of a calculation for later use? We can
do this by assigning the result to a variable. In R, you assign a value to a
variable using the `<-` operator: 
[`<-` assignment operator]{.aside}


```{r}
x <- 2
y <- sin(pi/2)
z <- x + y
```

If you want to see the value of a variable, just type its name in the
console and press `Enter`, or use `print()` function:
[`print()`]{.aside}


```{r}
print(z)
```


::: {.callout-tip}
## Assignment operator

Many other languages use `=` as an assignment operator. In R, you can use
`=` as well, but do yourself a favour and **don't**. Use `<-` instead. Why?
Your code will be more readable and you will avoid many common mistakes.
:::

Variables are like boxes in which you can store values. However, unlike
boxes, when you assign one variable to another, the first variable keeps
its content:


```{r}
x <- 2
y <- x
x
```

We now come to a very important point which we will revisit often, as it is
one of the most common beginner (and not only beginner) mistakes. When you
forget to assign the value to a variable, R will print it to the console,
but the variable **will not be modified**:


```{r results=FALSE}
x <- 2
# prints 0.9092974:
sin(x) 
# prints 2
x 
```

In the code above, the value of `x` is not changed by the `sin()` function.
**To store the value of a function, you need to assign it to a variable**:

```{r results=FALSE}
x <- 2
# does not print anything:
x <- sin(x) 
# prints 0.9092974:
x    
```

Please spend some time on this, as it is a very common source of errors.

::: {.callout-important}
As a rule of thumb[^exceptions], if the expression you type in your script
does not contain the `<-` operator, it will not modify any variables.
:::

[^exceptions]: There are exceptions to this rule, but they are relatively rare and
we will not discuss them here.

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-variables-and-rstudio}
Create a variable using `x <- 42`. Take a look at the Environment pane in
RStudio (top left part of the window). Do you notice anything?

::: {.callout-caution icon=false collapse="true"}
## Solution

A new entry appeared in the "Environment pane". It shows that there is a
new variable present in your environment.
:::

:::
:::

### Character variables

Variables can store not only numbers, but also text. Text in R is called a
**character string**. To create a character string, you need to enclose the
text in quotes (both single and double quotes are allowed, but try to be
consistent and use only one type). For example:


```{r}
name <- "January"
city <- "Hoppegarten"
greeting <- "Hello, world!"
```

Character variables cannot be used with algebraic computations, the
following code will throw an error:


```{r error=TRUE}
# this does not work!
name + city
```

However, if you want to "add" two character strings (that is, concatenate
them), you can use the `paste()` function:
[`paste()`]{.aside}


```{r}
paste(name, city)
```

Quite often, you don't want to have a space between the two strings. This
is such a common operation that R has a shortcut for it:
[`paste0()`]{.aside}


```{r}
paste0(name, city)
```


::: {.callout-tip}
## Other types

There are other types of data types in R. Later on, we will briefly touch on
*factors*, which look like character strings but behave like numbers.
Another important data type is a *logical* type, which can have only two
values: `TRUE` and `FALSE`. We will talk about logical types in more detail
tomorrow.
And under the hood, numeric vectors can be either integers (numbers like 1,
2, ...) or floating point numbers (numbers like 1.1, 2.2 or $\pi$).
:::

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-variables}
## Variables

Create the following variables in your script:

 * `name` with the value of your first name
 * `city` with the value of the city where you live
 * `age` with the value of your age
 * `greeting` with the value "Hello,"
 * concatenate the variables `greeting` and `name` and store the
   result in a new variable `hellothere`

::: {.callout-caution icon=false collapse="true"}
## Solution

```{r}
name <- "January"
city <- "Hoppegarten"
age <- 199
greeting <- "Hello,"
hellothere <- paste(greeting, name)
```




:::
:::
:::

### Workspaces, history and environments

XXX

### Tab completion


XXX

## Vectors and vectorization

### Vectors

Variables can (and do) store a lot more than single values. One of the most
basic and important data types in R is a **vector**. A vector is simply a
sequence of values – just like in maths. And you know what? You have
already created vectors in R.
In mathematics,
any scalar value can be treated as a one-dimensional vector and it is
exactly like that in R: any single value is a 1-element vector, including
all the variables that you have created in the previous exercise.

To create a vector with more than one value, you can use the `c()` function
[`c()`]{.aside}
("c" stands for "combine"). For integer numbers, you can use the `:` operator
[Creating a sequence of numbers with `:`]{.aside}
to create a sequence of numbers.
For example:


```{r}
sequence <- 5:15
numbers <- c(10, 42, 33, 14, 25)
person <- c("January", "Weiner", "Hoppegarten")
```

It is also possible to combine two vectors longer than 1 into one:
[Combining vectors]{.aside}


```{r}
first_v <- c(1, 2, 3)
second_v <- c(4, 5)
combined_v <- c(first_v, second_v)
print(combined_v)
```


You can access individual elements of a vector using the `[ ]` operator:
[Accessing elements of a vector with `[ ]`]{.aside}


```{r}
numbers[1]
person[2]
```

But hey, I told you that every value is a vector in R, right? And that
includes the indices `1` and `2` that you have just used. So, what would
happen if we used more than two values as an index? Try it:


```{r}
numbers[1:3]
person[3:1]
sel <- c(1, 5, 3)
numbers[sel]
```

As you can see, not only can you use a vector as an index, but you can also
use a *variable* as an index.

::: {.callout-warning}
## Do not use a comma

It is tempting to select, say, first and the third element of a
vector `numbers` by writing `numbers[1, 3]`. This will not work! As you
will see tomorrow, this way of writing is for two-dimensional objects. You
must use a vector as an index: `numbers[c(1, 3)]`.
:::


::: {.callout-tip}
## Vectors and indices

In many (most?) programming languages, the first element of a vector is
accessed using the index 0. For example in Python, to access the first
element of an array, you need to type `array[0]`. This has something to do
with how computers work. In R, the first element
is always `1` – R was designed by statisticians, and in mathematics we
always start counting from 1. For some reason, this seems to make some computer
scientists angry.
:::

### Named vectors

Accessing elements of a vector using indices is all well and good, but
sometimes it can be very inconvenient, especially if the vectors are very
long. Or maybe you do not remember the order in which you have stored the
elements of the vector – was the last name first, or second element of the
`person` vector?

Vectors allow you to name their elements. We can either define the names at
the very beginning, when we create the vector, or we can add them later
using the `names()` function. Here is how you can do it:
[Named vectors]{.aside}


```{r}
person <- c(first="January", last="Weiner", city="Hoppegarten")
```

Once you have named the elements of a vector, you can access them using
their names:

```{r}
person["city"]
person[c("first", "last")]
```

Or, we can change the names with the `names()` function:
[`names()`]{.aside}


```{r}
names(person) <- c("name", "given", "place")
person
```


### Assigning values to selected elements

OK, one more thing about vectors. Above we have selected elements from a
vector. It turns out, we can do more with that selections then just print
it to a console:
[Assigning values to selected elements]{.aside}


```{r}
numbers <- c(10, 42, 33, 14, 25)
sel <- c(1, 5)
numbers[sel] <- c(100, 500)
numbers
```

Here is what happened: we assigned new values to the first and the fifth
element of the vector `numbers`. This is a very powerful feature of R and
you will be using it a lot.



::: {.callout-caution icon=false appearance="simple"}
::: {#exr-accessing}
## Accessing and modifying vectors

 * Create a vector with the first 10 prime numbers. Call it `primes`.
 * How do you access the 3rd, 5th and 7th prime number? 
 * What happens when you do `primes[11]`?
 * What happens when you do `primes[11] <- 31`?
 * What happens when you do `primes[15] <- 47`?
 * What happens when you do `primes[-1]`?
 * Change the 3rd, 5th and 7th prime number to 100, 500 and 700,
   respectively.

::: {.callout-caution icon=false collapse="true"}
## Solution


```{r}
# note that 1 is not a prime number!
primes <- c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)
primes[c(3, 5, 7)]

# returns a special value, NA
# (not available)
primes[11]

# adds a new element to the vector
# at the end
primes[11] <- 31
primes

# adds a new element to the vector
# at position 15, fills the gap with
# NAs
primes[15] <- 47
primes

# returns the vector without the first
# element
primes[-1]

primes[c(3, 5, 7)] <- c(100, 500, 700)

```




:::
:::
:::

### Vectorization

Vectors are very useful – but wait, there is more. What happens if we add a
value to a vector? Try it:

```{r}
numbers <- c(10, 42, 33, 14, 25)
numbers + 10
```

As you can see, R has added the value 10 to every single element of the
vector `numbers`. The same thing happens with other operators, like `-`,
`*` and `/`. Try it yourself.

This is called **vectorization** and it is one of the most powerful features
[Vectorization]{.aside}
of R compared to other languages. It will allow you to write very concise
and, at the same time, readable code.

The vectorization works not only with operators like `+`, `-`, `*` and `/`,
but with many functions. For example, it works with most of the
mathematical functions like `sin()` or `log()`. Try it:


```{r}
log10(numbers)
sin(numbers)
```

However, there is a catch. What happens if you try to add two vectors when
both of them with more than one element? First, let us try to add two
vectors of the same length:


```{r}
numbers1 <- c(1, 2, 3)
numbers2 <- c(4, 5, 6)
numbers1 + numbers2
```

As you can see, R has added the first element of the first vector to the
first element of the second vector, the second element of the first vector
to the second element of the second vector, and so on. Makes sense, right?
Same would happen if we were to subtract, multiply or divide the vectors
(or use logical operations, which you will learn on Day 3).

Imagine the two vectors one beneath the other:

```
numbers1:   c(1,    4,    5)
              +     +     +
numbers2:   c(2,    5,    6)
              ↓     ↓     ↓
result:     c(3,    9,   11)

```

R is simply adding up corresponding elements.
This does not look like much now, but trust me, it will be extremely useful
in the future.

However, if the vectors have *different* lengths, it is a different story
altogher. Take a look:


```{r}
numbers1 <- c(1, 2, 3)
numbers2 <- c(4, 5)
numbers1 + numbers2
```


Ooops, what exactly happened here? First thing to note is that *there was
no error*. There was a *warning*, but still our code executed and produced
a result. But what is that result? For the first element of the result, it
is clear enough: `1 + 4 = 5`. Same for the second, `2 + 5 = 7`. But what
about the third? It seems that R added `3 + 4 = 7`. But why?


R noticed that it is missing an element to be added to the third element of
the vector `numbers1`. So, it did what is called **recycling**. It
[Recycling]{.aside}
"rewound" the vector `numbers2` to the beginning and added the first
element of `numbers2` to the third element of `numbers1`. However, since
after the rewinding and adding one element of vector `numbers2` was left
(because `numbers1` did not have any more elements), R issued a warning. 

```
numbers1:   c(1,     2,      3)
              +      +       +
numbers2:   c(4,     5)    c(4,    5)
              ↓      ↓       ↓
result:     c(3,     9,     11)

```



If
the length of the first vector was a multiple of the length of the second
vector, R would not have complained:


```{r}
numbers1 <- c(1, 2, 3, 4, 5, 6)
numbers2 <- c(7, 8)
numbers1 + numbers2
```

See? No warning. R was recycling the second vector over and over again.
Recycling is a dangerous business: if you are not careful, you can get
results which you have not expected.

```
numbers1:   c(1,     2,      3,     4,     5,     6)
              +      +       +      +      +      +
numbers2:   c(7,     8)    c(7,     8)   c(7,     8)
              ↓      ↓       ↓      ↓      ↓      ↓
result:     c(8,    10,     10,    12,    12,    14)

```

Take it slow. This is advanced stuff, but I had to warn you already at this
stage – this is one of the common sources of errors in R. Watch out for
this "longer object length is not a multiple of shorter object length"
warning.

::: {.callout-tip}
## Recycling advice

Here is our advice to you: either use a vector and a single element vector, or two 
vectors of the same length. And in the cases where, for some reason, you
need to recycle, make sure that you know what you are doing. For example,
check the length of both vectors.
:::


With vectors that have only a couple of numbers it is quite easy to see
what is happening, but what if you have thousands of variables? In other
words, how to check the lenght of a vector? You can use the `length()`:
[`length()`]{.aside}


```{r}
length(numbers1)
length(numbers2)
```

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-vectorisation}
## Vectorisation

 * Create a vector with several numbers and try to add, subtract, multiply and
   divide it by a single number. What happens?
 * Say, you have three values which are the diameters of three circles: 1,
   5 and 13. You would like to have a vector containing the areas of these
   circles. What is the simplest way of doing that?
 * How do you check the length of this vector?
 * One vector, `lengths`, contains the lengths of the sides of three rectangles,
   and the other, `widths`, contains their widths. Create a
   vector containing the areas of these rectangles.

::: {.callout-caution icon=false collapse="true"}
## Solution

```{r}
# create a vector
numbers <- c(1, 2, 3, 4, 5)
# add, subtract, multiply and divide
numbers + 10
numbers - 10
numbers * 10
numbers / 10

diameters <- c(1, 5, 13)
areas <- pi * (diameters/2)^2
areas

length(areas)

lengths <- c(1, 2, 3)
widths <- c(4, 5, 6)
areas <- lengths * widths
areas
```
:::

:::
:::

::: {.callout-tip}
## Messages, Warnings and Errors

R has three types of information to pass to you: messages, warnings and
errors. Messages are just that – messages. Warnings are messages that tell
you that something might be wrong and you should pay attention, but R will
nonetheless do what you asked it to do. Errors stop the execution of your
code, but warnings do not.

You should pay attention to warnings, but you do not have always to do
something about them – some you can safely ignore. Errors, on the other
hand, you should always fix.
:::


### The special value `NA`

One more thing: there are a couple of special values in R that you should
know about. One of the most prominent, useful and frequently encountered is
the `NA` value, which stands for "Not Available". You will see it
[`NA`]{.aside}
frequently when you work with data.

It is possible to apply mathematical operations to `NA` values, but the
result is inadvertently `NA`:


```{r}
NA + 1
numbers <- c(1, 2, NA, 4)
numbers * 3
```

This also goes for some functions, which, quite often, have a special
parameter to omit the `NA` values. For example, the `mean()` function
[`mean()`]{.aside}
calculates the mean of a vector:


```{r}
numbers <- c(1, 2, NA, 4)
mean(numbers)
mean(numbers, na.rm=TRUE)
```

::: {.callout-tip #tip-functions}
## Useful functions

There is a whole bunch of functions that you can use to work with vectors,
and here are some of them – with mostly self-explanatory names: `sum()`,
`min()`, `max()`, `range()`, `sd()`, `var()`, `median()`, `quantile()`.
[Descriptive statistics: `sum()`, `min()`, `max()` etc.]{.aside}
Look them up in the help system by typing, for example, `?sum` in the console.
:::

The `NA` value very frequently pop up when you try to convert a character
vector holding what looks like numbers into a numeric vector. We will see
many such examples in the days to come; the conversion is often done using
the `as.numeric()` function. For example, it is quite common that values
[`as.numeric()`]{.aside}
typed in a spreadsheet contain comments or values which look like this `> 50`
(measurement out of range).


```{r}
imported_data <- c("10", "20", "30", "> 50", "40", "N.A.", "60 (unsure)")
# this will generate a warning
imported_data <- as.numeric(imported_data)
imported_data
```

As you can see, R conveniently warns you that some elements of the vector
were changed to `NA`. Look out for that warning!

::: {.callout-tip}
## Special values
There are a few other special values in R that behave similarly to `NA`.
[`Inf`, `-Inf` and `NaN`]{.aside}
`Inf` stands for infinity, you will get it when you divide a positive number by zero:
`1/0`. `-Inf` is the negative infinity (when you divide a negative number
by 0), and `NaN` stands for "Not a Number" – this is what you get when you
try to subtracting `Inf - Inf` or dividing `0/0`. They have also other uses
– for example, if a function wants to know how many rows of output you
would like to see, and your answer is "all of them", you can use `Inf` as
the number of rows.
:::


## Putting it all together

### Water lillies on a lake {#sec-lilies}

There is an old puzzle that goes: "On a lake, there is a water lily. Each
day the lily doubles in size. After 30 days, the lily covers the entire
lake. On which day was the lily covering half of the lake?".

In the following section we will model the behavior of the lily using R.
Let us start with some assumptions. First: we designate the first day as
Day 1. Second: every day, the lily doubles the area it covers. Third: on
the first day, the lily covers 1% of the lake.

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-lilies}
## Modelling water lilies

Take a piece of paper and a pen. Your task is to come up with a formula to
describe the area of the lily on the $n$-th day. Write down the formula.

Hint: if you are stuck, try to calculate the area of the lily on the first
few days.
:::
:::

There is an important point that we wish to demonstrate here. Quite often
it pays off to close your laptop and *think* for a moment what it is it
that you want to do, rather than start coding right away. Pen and paper are
helpful (we will be making this point again when it comes to
visualizations). If you do not have a clear idea of *what* you want to do,
you can get stuck thinking about what you already know how to do. 

The formula for calculating the area of the lily on the $n$-th day is
$0.01 \times 2^{n-1}$. You can come up with that result quite easily if you
consider the first few days. On day 1, the area is $1\% = 0.01$. On day 2, is twice
that, that is, $0.01 \times 2 = 0.01 \times 2^1 = 0.02$. On day 3, it is
twice the area from the previous day: $0.02 \times 2 = 0.04 = 0.01 \times 2
\times 2 = 0.01 \times 2^2$. And again, on day 4, it is $0.01 \times 2^3$.
And so on[^formula]. We can show it in a table:

[^formula]: If started counting from 0 – that is, if we designated the
first day as Day 0 – the formula would be $0.01 \times 2^n$.

| Day | Area | Calculation | Formula |
|-----|------|---------|---------|
| 1   | 0.01 | $0.01$ | $0.01 \times 2^0$ |
| 2   | 0.02 | $0.01 \times 2$ | $0.01 \times 2^1$ |
| 3   | 0.04 | $0.01 \times 2 \times 2$ | $0.01 \times 2^2$ |
| 4   | 0.08 | $0.01 \times 2 \times 2 \times 2$ | $0.01 \times 2^3$ |
| 5   | 0.16 | $0.01 \times 2 \times 2 \times 2 \times 2$ | $0.01 \times 2^4$ |

Once we have the formula, it is very easy to calculate the area covered by
water lillies on the first 10 days. We will use vectorization to do this:


```{r}
days <- 1:10
area <- 0.01 * 2^(days - 1)
area
```

This calls out for a plot. We will talk about visualizations more extensively
on Day 5, but for now, we will use a very basic and simple function to plot
the area of the lily on the first 30 days. The function is called `plot()`
and can be used to plot a graph of two vectors. The first vector is the
days, the second vector is the area.


```{r}
plot(days, area, type="b")
```

[plot(..., type="b")]{.aside}

O-K, days and area are clear, but what is this `type="b"`? This is a
[Named arguments]{.aside}
so-called *named* argument[^argument]. The `plot()` function has many arguments, and
if you want to use only some of them, you can use their names with an equal
sign. You will see that a lot in the days to come. This particular
argument, `type`, tells R what kind of plot to draw. The `"b"` stands for
"both" and tells R to draw both points and lines. If you want only points,
you can use `"p"` (or simple leave the argument out), if you want only
lines, you can use `"l"`.

[^argument]: Full disclosure: all arguments have names in R and can be
named explicitely. However, some of the arguments have a default value, so
we do not have to specify them unless we need them. The `type` argument is
one of them. Others must always be specified.

Note another thing on this plot: after day 7, the area is greater than 1.
But 1 means 100%, so after day 7, the lily covers more than the entire
lake. Obviously, this is not possible – and it shows a limitation of our
model. We can show it by adding a horizontal line to the plot:


```{r}
plot(days, area, type="b")
abline(h=1, col="red")
```

[abline()]{.aside}

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-day1-lilies-plot}
## Plotting water lilies

 * Create the same plot using the `plot()` function, but add, as a parameter, `col="blue"`. What happens? 
 * Now add a parameter `pch=19`. What happens?
 * Use the argument `xlab` to label the x-axis with "Day". Use the argument
   `ylab` to label the y-axis with "Area". Use the argument `main` to give
   the plot a title.
 * Use the argument `ylim=c(0, 1)` to change the range of the y-axis. How
   would you change the limit of the x axis?
 * What is the formula for the area of the lily assuming
   that each day, the lily covers 1.75 times the area of the previous day?
 * Create a new area vector (call it `area_slow`) which will be calculated
   with the new formula.
 * Add the new vector to the plot using the function `lines()`. What does
   the `lines()` function do? (Hint: type `?lines` in the console).

([Solution](solutions.html#exr-day1-lilies-plot))
:::
:::

### Functions in R

R is a so-called *functional* language. This is different from many other
languages (including Python). It has some interesting implications which we
will partially explore over the next few days. For now, however, we will be
content with one important statement: in R, most of the stuff you do, you
do using functions. A function takes zero or more arguments and returns
exactly one argument.

During this course, we will not really discuss or require creating your own
functions. However, we would nonetheless like to show you how it is done.
There are two reasons for that. Firstly, it is really, really easy.
Secondly, it will help you understand how functions work in R, and that
will help you understand how to use functions that others have created.

In the water lilies example we have used a formula to calculate the area of
the lily on the $n$-th day. The formula includes three parameters: the
initial fraction of the area covered by the lily on day 1, the day number and the factor by which
the area is increased each day. We will now create a function that takes
two parameters: the day (or days) and the factor, and return
the area of the lily on that day. Here is how you can do it using
`function()` keyword in R:
[`function() { ... }`]{.aside}


```{r}
area_lily <- function(day, fct) {
  ret <- 0.1 * fct^(day - 1)
  return(ret)
}
```

As you can see, the function is created using the `function` keyword. In
parentheses (`(` and `)`), you specify the arguments that the function
takes, separated by commas. Then comes the body of the function, enclosed
in the curly braces (`{` and `}`). On the last line of the function code,
the `return()` function is used to return the value of the `area_lily`
function.

Once you have run the code above, you can use it to calculate the area of
the lily on the first 10 days like this:

```{r}
area <- area_lily(1:10, 2)
area
```

One interesting and important fact about the defining the functions is that
you use the assignment operator `<-` to assign the function to a variable.
In other words, `area_lily` *is*, in fact, a variable! A variable which holds
not a value or character string, but computer code that can be used to do
stuff. You can copy it to another variable and it will behave exactly as
the original function:


```{r}
area_lily2 <- area_lily
area_lily2(1:10, 2)
```

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-lilies-plot}
## Creating your own function

Modify the `area_lily` function so that it takes three arguments: the day,
the initial fraction and the factor. Use the new function to calculate the
area of the lily on the first 10 days with the initial fraction of 0.001 and
the factor of 1.5. What is the area on the 10th day?

::: {.callout-caution icon=false collapse="true"}
## Solution

```{r}
area_lily <- function(day, fct, start) {
  ret <- start * fct^(day - 1)
  return(ret)
}

area_lily(1:10, 1.5, 0.001)
```
:::

:::
:::


## Coding practices

### Computer programs as means for communication

It is now time to conclude today's lesson with a bit of philosophy. When
you write an R script, the first goal you have in mind is to analyse your
data – in other words, by means of what you write you are trying the
computer to do something for you. That is correct and fine, but there is
an important aspect of programming that is often overlooked.

When you write a program, you are writing it not only for the computer, but
also for other people. These other people may include your colleagues,
readers of your scientific articles, your students, and, last but not
least, a future version of yourself. All these people need more then just
a piece of code that works. You will quickly find it out yourself when you
open a script or a project that you have not been working on for a few
months – trust me on this, you will not know what it does, how it does and
sometimes even whether you have written it or copied from somewhere.

You might be thinking that you are never willing to show your code to
another person. You are wrong, and not only because it is useful *to you*
for another person to review your code. Firstly, you will *want* to share
your code because as a scientist you will want to share your results, and
results are nothing if the methods to obtain them are unknown. And
secondly, you will *need* to share your code because you will be asked to
do so by your colleagues (yes, I was as surprised as you will be when I was
asked to share my code for the first time). And thirdly, your code is part
of your methods and you will *have* to share it when you publish your
results[^publish].

[^publish]: Top journals already require that you share your code when you
publish your results. This will become more and more common in the future.

For communication with another human being to be efficient, you need to
make it as clear as possible. There are several ways how to make your code
more readable and understandable. Here are some of them.

**Comments**. Comments are lines in your code that are not executed. In R,
they start with a `#` sign. Comments help to explain what exactly are you
[Comments with `#`]{.aside}
trying to achieve with your code. The old saying goes: "Code tells you how,
comments tell you why". You can hardly overdo with comments, but you can
easily underdo.

**Naming**. The names of your variables, functions and files should be
meaningful. If you have a variable that stores the number of days, call it
`days`, not `x`. If you have a function that calculates the area of a
circle, call it `calculate_circle_area()`, not `f()`. If you have a comma
separated values (CSV) file that contains the CRP values, call it
`crp_values.csv`, not `data.txt`. This is sometimes much more difficult
than it looks, but it is very important. Also, that does not mean that you
can't use short names – but use it only for "throwaway" variables that are used
only once or twice, or for example code.

**Formatting**. Your code should be formatted in a consistent way. For
example, you should always put a space around your operators, like `x <- 2`
(and not `x<-2`), you should always put a space after a comma, like
`c(1, 2)` and not `c(1,2)` (and also not `c( 1 , 2 )`). 
Lines should not be too long – 80 characters at most is a good rule of thumb. 
If a line is too long, you can split it into several lines – R will not
mind.
See [here](http://web.stanford.edu/class/cs109l/unrestricted/resources/google-style.html)
for a more detailed guide on how to format your code.

### Example

The following fragment of code shows how you should *not* format your code:

```{r eval=FALSE,echo=TRUE}
#| code-line-numbers: true
a<- 4
b <-c(1,10, 
20, 21, 5)
r<-sqrt(sum((b-mean(b))^2)/
               a)
```

The code *is* correct, but it is hard to read. What does it do, quickly? If
you carefuly examine it, you will see that it calculates the standard
deviation of the vector `b`, following the formula

$$SD = \sqrt{\frac{\sum_{i=1}^{n} (x_i - \bar{x})^2}{n-1}}$$

where $n$ is the length of the vector `b`, $x_i$ is the $i$-th element of
the vector `b` and $\bar{x}$ is the mean of the vector `b`.
However, there are several issues.

Firstly, there are no comments in the code which would give a hint of what
it does. Secondly, $n - 1$ (the variable `a`) is hard encoded - if you
modify the vector `b` by adding one number, the code will execute, but the
result will be incorrect.

Thirdly, line 4 combines several operations making it very hard to read. It
should be split for clarity. The following code is much more readable:

```{r eval=FALSE,echo=TRUE}
#| code-line-numbers: true
# ---------------------------------------------------------
# Calculating the standard deviation of a sample
# ---------------------------------------------------------

# example values for five samples
samples <- c(1, 10, 20, 21, 5)
samples_n <- length(samples)

# calculate standard deviation of samples manually
samples_mean <- mean(samples)
samples_devs <- samples - samples_mean

# samples variance
samples_var <- sum(samples_devs^2) / 
                (samples_n - 1)

samples_sd <- sqrt(samples_var)
```

This makes it absolutely clear what you are trying to do, and, in addition,
calculates the mean, the deviations, sample length and sample variance –
all of which might come in handy later on.
Also note of the use of `# ----`... comments. Programmers often use these
to highlight the beginning of a new section of code. This is not necessary,
but adds to readability. Lines 14 and 15 show how you can split a line of
code in a way that is both readable and clear.

Of course, the example is a bit silly – R has a lot of built-in statistical
functions, and standard deviation naturally is one of them. You can
calculate the standard deviation of a vector `b` using the `sd()` function:
[`sd()`]{.aside}

```{r eval=FALSE,echo=TRUE}
samples_sd <- sd(samples)
```

Nonetheless, the principle stands.

## Review

Things that you learned today:

 * Working with R and RStudio
   * Creating and running scripts
   * Using the console
   * Using the "Environment" panel of RStudio
   * Using comments with the `#` sign
   * Using tab completion
 * Variables
   * Assigning values to variables
   * Using variables in calculations
   * Using character variables
   * pasting together character variables with `paste()` and `paste0()`
 * Vectors
   * Creating vectors with `c()` and `:`
   * Accessing elements of a vector with `[ ]`
   * Named vectors
   * Assigning values to selected elements
   * Vectorization
   * Recycling
 * Useful functions
   * `sqrt()`, `log()`, `log2()`, `log10()`, `sin()`, `cos()`, `tan()`
   * `sum()`, `mean()`, `min()`, `max()`, `range()`, `sd()`, `var()`, `median()`, `quantile()`
 * Other
   * The special values `NA`, `Inf`, `-Inf`, `NaN`
   * Logical values `TRUE` and `FALSE`
   * Functions in R
   * Plotting with `plot()`
   * Adding parameters to functions
   * Coding practices

XXX
