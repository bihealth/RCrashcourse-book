# Appendix: Wide vs long data {.unnumbered}


```{r echo=FALSE}
options(width=80)
```




## Wide and Long format

Consider a data set with laboratory measurement for a number of patients.
We can measure, for example, the concentration of calcium, of C-reactive
protein, number of white blood cells in billions per liter etc., etc.


```{r echo=FALSE,message=FALSE,warning=FALSE}
library(tidyverse)
library(tinytable)
people <- c("Frank N. Stein", "Dr. Jekyll", "Mr. Hyde")
labres <- read_csv("Datasets/labresults_full.csv") |>
  filter(Timepoint == "D1") |>
  select(SUBJ, LBTEST, LBTESTCD, LBORRES, LBORRESU) |>
  filter(LBTESTCD %in% c("CA", "CRP", "WBC")) |>
  mutate(LBORDATE = 
    sample(seq(as.Date("2021-09-01"), as.Date("2022-07-10"), by="day"), n(), replace=TRUE)) |>
  mutate(LABTECH = sample(people, n(), replace=TRUE))

labres_w <- labres |>
  pivot_wider(id_cols = SUBJ, names_from=LBTESTCD, values_from=LBORRES) 

labres_w2 <- labres |>
  pivot_wider(id_cols = SUBJ,
    names_from = LBTESTCD,
    values_from = c(LBORRES, LBORRESU, LABTECH, LBORDATE),
    names_vary = "slowest"
    )
```

We have many ways to represent the data in a
data frame. For example, we can put all measurements for a patient in one
row, and have a column for each measurement type. This results in a nice,
compact format, where each row corresponds to one patient, and each column
to one measurement. Here is how it might look like:

```{r echo=FALSE}
tt(labres_w[1:5,], digits=2)
```

This is called the **wide format**. It is easy to view, and suitable for some
applications – like principal component analysis. It is also easy to filter
the data by patients, or by certain measurement parameters. However, we
can't use it for many other applications, for example for plotting and many
statistical applications.

And what if we want to include additional information about the
measurements? For example, when the measurement was made, in what units, 
who conducted the test? We could add columns for each of these, but then we
would have a mess.

```{r echo=FALSE}
tt(labres_w2[1:5,], digits=2)
```

Yeah, no, this is not going to work. It is hard to view manually, but for
computing applications it is even worse. We cannot easily convert it to a
matrix, and we *still* can't use it for `ggplot2` or linear modeling. It
is, quite probably, the worst of both worlds[^worst].

[^worst]: Actually, that is not true. Even worse is adding information
*directly into the column names*, like `CA (mmol/L, 2021-09-01, Dr. Jekyll)`. 
Close second comes adding information in the values directly,
like `7.9 mmol/L (2021-09-01, Dr. Jekyll)`, but at least here we can
attempt to automatically parse the values – as long as there are no
typos...

Enter the **long format**. In the long format, each row corresponds to one
measurement, and one measurement only:

```{r echo=FALSE}
tt(labres[1:9,], digits=2)
```

This is by far the most advantageous format for transfering and storing
data. It is also the most flexible format for data analysis. We can easily
convert it to the wide format (possibly losing some information, like
units or who conducted the test), or to a matrix, or to a plot. We can
easily filter the data, or do statistics on it.

However, as you can see above, some of the information might be duplicated
many times – for example, if we have a column with patient's name, it will
appear many times next to each measurement of that patient.

To sum it up:

 Long advantages:

  * easier to filter, process, visualize, do statistics with
  * focused on measurement ("patient ID" or equivalent is a covariate, and so is measurement type)
  * safer 

 Wide advantages:

  * groups data by a covariate ("patient ID")
  * can be easier to manage (each column one measurement type)
  * less duplication of information (smaller files)

I recommend using the long format in most situations, however there are
always occasions where we need to move from one option to the other. For
example, we might want to do a PCA – so we need to convert to the wide
format. Or the wide format is more suitable for manual data entry – and we
have to convert it to the long format for analysis.

It is crucial to be fluent in switching between both formats.


::: {.callout-tip}
## Use long format

In general, you should probably always use the long format as the main
format for your data. It is easier to work with, and you can always convert
it to wide format if you need to. 

There are exceptions to this rule – typically when it comes to
high-throughput data (like RNA-Seq).
:::

## Converting from wide to long:

First, let's read an example wide data set:

```{r message=FALSE, warning=FALSE}
library(tidyverse)
wide <- read_csv("Datasets/wide_example.csv")
wide
```

This is clearly a wide format – each row corresponds not to one observation
(one measurement), but one subject. We want to convert this to long format,
where each row corresponds to one observation (and therefore, for each
subject, there are three rows).

[`pivot_longer()`]{.aside}
```{r message=FALSE, warning=FALSE}
pivot_longer(wide, cols=control:cond2,
  names_to="condition", values_to="measurement")
```

Note that we must put quotes around `condition` and `measurement` in the
code above. These are column names, but the columns don't exist yet.

## Converting from long to wide

Here is another example data set, this time in long format:

```{r message=FALSE, warning=FALSE}
long <- read_csv("Datasets/long_example.csv")
long
```

As you see, there are three subjects again, each with three measurements (one
control, one for condition 1, and one for condition 2). We want to convert
it to wide format, so we expect one row per subject, in total three rows.

We can use the `pivot_wider()` function to do this. We need to specify which
column contains the values that should be spread out, and which column
contains the names of the new columns. 
[`pivot_wider()`]{.aside}

However, watch out. The first thing we might want to try does not give the
expected result:

```{r}
## not what we wanted!!! Why?
pivot_wider(long, names_from=condition, values_from=measurement)
```

The problem is in the sampleID column. Given that names of the variables
are in the `condition` column, and `measurement` is in the `measurement`
column, R considers all the remaining columns to be the identifier columns.
But the column `sampleID` contains only unique values, so they must be put
in separate rows, as above. 

To fix this, we need to tell R not to use `sampleID` as an identifier
column; instead, only the subject column should be used as an identifier.
We can also throw in the `sex` column if we want to keep it, since it has
only 1 value per subject.


[`pivot_wider(id_cols=...)`]{.aside}
```{r}
## Instead: 
pivot_wider(long, id_cols=c(subject, sex),
                  names_from=condition, values_from=measurement)
```

::: {.callout-caution icon=false appearance="simple"}
::: {#exr-widelong-exercise}
## Converting to long format

Convert the following files to long format:

 * `labresults_wide.csv`
 * The built-in iris data set (`data(iris)`)
 * `cars.xlsx` (tricky! hint: how do you tell which value in the long
   format belongs to which row in the wide format?)

Clean up and convert to long format (what seems to be the problem? How do
we deal with that?):

 * `mtcars_wide.csv`

:::
:::
