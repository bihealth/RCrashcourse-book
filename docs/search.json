[
  {
    "objectID": "day2-complex-structures.html",
    "href": "day2-complex-structures.html",
    "title": "2  Day 2: Complex data structures",
    "section": "",
    "text": "2.1 Goals for today",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex data structures</span>"
    ]
  },
  {
    "objectID": "day2-complex-structures.html#goals-for-today",
    "href": "day2-complex-structures.html#goals-for-today",
    "title": "2  Day 2: Complex data structures",
    "section": "",
    "text": "Complex data structures (matrices, lists and data frames)\nLogical vectors and subsetting",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex data structures</span>"
    ]
  },
  {
    "objectID": "day2-complex-structures.html#logical-vectors",
    "href": "day2-complex-structures.html#logical-vectors",
    "title": "2  Day 2: Complex data structures",
    "section": "2.2 Logical vectors",
    "text": "2.2 Logical vectors\n\n2.2.1 Truth and falsehood\nYesterday, we mentioned briefly two special values in R: TRUE and FALSE. These are logical constants, and they are used to represent truth and falsehood, respectively. Using these values, it is possible to create logical vectors – vectors that contain only these two values.\n\nlogical_vector &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE)\n\nThe FALSE value is equivalent to 0, and TRUE is equivalent to 1. That means, we can use logical vectors in arithmetic operations. One very common application of this is using sum() to count the number of TRUE values in a logical vector.\n\nsum(logical_vector)\n\n[1] 3\n\n\nLogical vectors are incredibly useful, because they can be used to subset other objects. For example, if you have a vector of numbers, you can use a logical vector to select some of the elements.\n\nnumbers &lt;- 1:5\nnumbers[ logical_vector ]\n\n[1] 1 3 4\n\n\nThe real usefulness of logical vectors comes when you create them using different operators that check for equality, inequality, etc. Let’s look at that in more detail.\n\n\n\n\n\n\nTRUE, FALSE and T and F\n\n\n\nIn R, TRUE and FALSE are the only two logical constants. However, there are also two other constants, T and F, which are equivalent to TRUE and FALSE, respectively. Do not use them. Unlike TRUE and FALSE, they can be overwritten, which can lead to chaos and mayhem.\n\n\n\n\n2.2.2 Comparison operators\nThere are six comparison operators in R:\n\n== – equality\n!= – inequality\n&gt; – greater than\n&lt; – less than\n&gt;= – greater than or equal to\n&lt;= – less than or equal to\n\nThey are vectorized like any other arithmetic operators, but their result is not a number – but a logical value. Take a look:\n\nnumbers &lt;- c(42, 3, -17, 0, -2, 1)\nnumbers &gt; 0\n\n[1]  TRUE  TRUE FALSE FALSE FALSE  TRUE\n\n\nFor each element of the vector, R checks if it is greater than zero. If it is, it returns TRUE, otherwise FALSE, producing, in the end, a vector containing as many elements as there were in the vector numbers. This logical vector can be used to subset the original vector.\n\n# prints only numbers greater than 0\nnumbers[ numbers &gt; 0 ]\n\n[1] 42  3  1\n\n# prints only numbers different from 0\nnumbers[ numbers != 0 ]\n\n[1]  42   3 -17  -2   1\n\n\nBut wait, there is more. There is a number of functions that check the elements of a vector and return logical vectors. One of the most commonly used and most useful of these is the is.na() function, which checks if an element is “not available”. This will come in handy later, when we start reading data from files – data which is full of NA’s!\n\nnumbers &lt;- c(42, 3, NA, 0, -2, 1)\nis.na(numbers)\n\n[1] FALSE FALSE  TRUE FALSE FALSE FALSE\n\n\nBut hey, this does not tell us which elements are NA’s. It is easy to see in the example above, but what if we have a vector with a million elements? Actually, to answer which elements are NA’s you can simply use the which() function:\n\nwhich(is.na(numbers))\n\n[1] 3\n\n\nFine, but what about the numbers which are not NA? What if we want to find all “good” numbers and store them for future use? In this case, we can use the ! operator, which negates the logical vector. That is, each TRUE becomes FALSE and each FALSE becomes TRUE.\n\nnas &lt;- is.na(numbers)\nnas\n\n[1] FALSE FALSE  TRUE FALSE FALSE FALSE\n\n# change TRUE to FALSE and FALSE to TRUE\n!nas\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n\nuseful_numbers &lt;- numbers[!nas]\nuseful_numbers\n\n[1] 42  3  0 -2  1\n\n\nThere is one more thing to mention here. The comparison operators == and != can be used to compare strings as well1.\n\npatient_measurements &lt;- c(1, 16, 7, 42, 3)\npatient_gender &lt;- c(\"male\", \"female\", \"female\", \"male\", \"female\")\npatient_measurements[ patient_gender == \"male\" ]\n\n[1]  1 42",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex data structures</span>"
    ]
  },
  {
    "objectID": "day2-complex-structures.html#matrices",
    "href": "day2-complex-structures.html#matrices",
    "title": "2  Day 2: Complex data structures",
    "section": "2.3 Matrices",
    "text": "2.3 Matrices\n\n2.3.1 Creating matrices\nMatrices are just what says on the box: 2-dimensional structures; just like in mathematics. They behave in a very similar way to vectors in R, for example, they always hold elements of the same type (either numeric, character, etc., but never elements of both types). If you have your data stored in an Excel spreadsheet, chances are that different columns have different types of data. You can hardly use matrices in such a case. In fact, you will probably rarely use matrices in R, at least at the beginning – however, they are very useful for storing large data sets, for example from a transcriptomic analysis. For storing “Excel-like” data you will be using lists and data frames, which we will discuss later today. Nonetheless, we will spend some time on matrices today – because 90% of what you will learn today about matrices you will be able to use with data frames as well.\nCreating a matrix is very simple. You can use the matrix() function, which takes a vector as input and reshapes it into a matrix:\n\nmtx &lt;- matrix(1:12, nrow = 3, ncol = 4)\nprint(mtx)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n\nAs you remember from yesterdays course, the 1:12 is a vector of numbers from 1 to 12. The nrow and ncol parameters specify the number of rows and columns, respectively. You don’t really need to specify both of them – if you specify only one, R will calculate the other one for you.\nAs you have noticed above, by default the matrix() function fills the matrix by columns. If you want to fill it by rows, you can use the byrow parameter:\n\nmtx &lt;- matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE)\nprint(mtx)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\n\nHere we use a special value – TRUE – which is a logical constant. It is equivalent to 1, but it is more readable. You can also use FALSE (or 0) to specify that you want to fill the matrix by columns (this is the default).\nIt is also possible to create a large matrix by passing only one value (typically 0 or NA) and specifying the number of rows and columns. In that case, you have to specify both nrow and ncol.\n\nmtx &lt;- matrix(0, nrow = 3, ncol = 4)\n\nYou can also create a matrix by binding vectors together, either by rows or by columns. The rbind() function binds vectors by rows, and the cbind() function binds vectors by columns. Always make sure that the vectors you bind have the same length and the same element type.\n\na &lt;- 1:3\nb &lt;- 4:6\nmtx &lt;- rbind(a, b)\nprint(mtx)\n\n  [,1] [,2] [,3]\na    1    2    3\nb    4    5    6\n\nmtx &lt;- cbind(a, b)\nprint(mtx)\n\n     a b\n[1,] 1 4\n[2,] 2 5\n[3,] 3 6\n\n\n\n\n\n\n\n\nMatrices and algebra\n\n\n\nR matrices are very powerful for linear algebra operations. If you ever learned linear algebra, you will find that R matrices can do pretty much everything you learned in class. For example, you can multiply matrices, transpose them, invert them, calculate determinants, etc. We will not cover these operations in this course.\n\n\nJust like vectors have a length which you can check with the length() function, matrices have dimensions – the number of rows and the number of columns. You can access them using the dim() function, which returns a vector of length 2 (row and column number), and with functions nrow() and ncol(), which return the number of rows and columns, respectively.\n\ndim(mtx)\n\n[1] 3 2\n\nnrow(mtx)\n\n[1] 3\n\nncol(mtx)\n\n[1] 2\n\n\n\n\n2.3.2 Accessing matrix elements\nFor vectors, we have used the square brackets ([]) to access elements. Same with matrices, really, however we have two dimensions now. Think about that: with vectors we could only select one or more elements. With matrices, it should be possible to select an element, a number of elements from a row (or the whole row), a number of elements from a column (or the whole column), or even a submatrix. All this is possible using the square brackets.\n\nmtx &lt;- matrix(1:12, nrow = 3, ncol = 4)\nprint(mtx)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n# Accessing the element in the third row and the second column\nmtx[3, 2]\n\n[1] 6\n\n# Accessing first three numbers in the second column\nmtx[1:3, 2]\n\n[1] 4 5 6\n\n# Accessing second to fourth numbers in the first row\nmtx[1, 2:4]\n\n[1]  4  7 10\n\n\n\n\n\n\n\n\nRows and columns\n\n\n\nWhen we talk about plotting, the first dimension, “x”, is usually the horizontal one, and the second dimension, “y”, is the vertical one. However, in R matrices, just like in real algebra, the first dimension corresponds to the rows, and the second dimension corresponds to the columns. You need to get used to it – it’s the same for data frames which you will be using extensively.\n\n\nIf you select more then one row and more than one column, you will get a new matrix – albeit smaller than the original one.\n\n# Selecting the first two rows and the last two columns\n# This will create a 2 x 2 matrix\nmtx[1:2, 3:4]\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n\n\nIf you want to access whole rows or columns, you do not need to specify anything – simply leave an empty space before (for selecting whole columsn) or after (for selecting whole rows) the comma.\n\n# Selecting the whole second row\nmtx[2, ]\n\n[1]  2  5  8 11\n\n# Selecting the whole third column\nmtx[, 3]\n\n[1] 7 8 9\n\n# Row 1 and three - returns a matrix\nsel &lt;- c(1, 3)\nmtx[sel, ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    3    6    9   12\n\n\nThis last example shows that just like with vectors, we can use a variable to make our selection.\n\n\n\n\n\n\nRemember!\n\n\n\n\nRows first, then columns\nIf you select a single column or a single row, you will get a vector\nIf you select more than one row or column, you will get a (smaller) matrix\nIf you select more rows or columns than are present, you will get a “subscript out of bonds” error\nVectors and matrices always have only one data type (string, numerical, logical etc.)\n\n\n\n\n\n2.3.3 Row and column names\nJust like in case of named vectors, we can name rows and columns of a matrix. However, for this we need two different functions: rownames() and colnames() (for row names and column names, duh).\n\nrownames(mtx) &lt;- c(\"first\", \"second\", \"third\")\ncolnames(mtx) &lt;- LETTERS[1:4]\n\nmtx[\"first\", ]\n\n A  B  C  D \n 1  4  7 10 \n\nmtx[ , \"A\"]\n\n first second  third \n     1      2      3 \n\n\nIn the code above, we use the LETTERS constant, which is a vector containing all the letters of the English alphabet. Just like constants pi and e, LETTERS is available in R by default, along with its lower-case counterpart, letters. It is useful for labeling.\nUnfortunately, we only have 26 letters in the alphabet, so what can we do with a matrix that has more columns than that? Well, we can use the same trick that Excel uses: after Z, we have AA, AB, etc.\nTo create such a long vector, we will use two functions: rep() and paste0().\n\n\n2.3.4 Using rep() to generate column names\nThe rep() function is a little and very useful utility function that repeats element of a vector a given number of times. It either repeats the whole vector several times, or, using the each parameter, repeats each element a given number of times:\n\nabc &lt;- LETTERS[1:3] # A, B, C\nabc3 &lt;- rep(abc, 3)\nabc3\n\n[1] \"A\" \"B\" \"C\" \"A\" \"B\" \"C\" \"A\" \"B\" \"C\"\n\na3b3c3 &lt;- rep(abc, each = 3)\na3b3c3\n\n[1] \"A\" \"A\" \"A\" \"B\" \"B\" \"B\" \"C\" \"C\" \"C\"\n\n\nIn the code above, we created two vectors, each of the length \\(3 \\times 3\\); first one goes “A, B, C, A, B, C, …”, and the second one goes “A, A, A, B, B, …”. To get at our goal, we would have to paste together the first element from the first vector with the first element from the second vector etc.:\n\n\n\na3b3c3\nabc3\nresult\n\n\n\n\nA\nA\nAA\n\n\nA\nB\nAB\n\n\nA\nC\nAC\n\n\nB\nA\nBA\n\n\nB\nB\nBB\n\n\nB\nC\nBC\n\n\n\nTo do this, we will use the paste0() function, which concatenates strings and is vectorized, so it does exactly what we need.\n\ncol_names &lt;- paste0(abc3, a3b3c3)\n\nOf course, we need all the letters (we used only three in the example above for demonstration purposes).\n\nn &lt;- length(LETTERS)\nabc3 &lt;- rep(LETTERS, n)\na3b3c3 &lt;- rep(LETTERS, each = n)\ncol_names &lt;- paste0(abc3, a3b3c3)\nlength(col_names)\n\n[1] 676\n\nhead(col_names)\n\n[1] \"AA\" \"BA\" \"CA\" \"DA\" \"EA\" \"FA\"\n\ntail(col_names)\n\n[1] \"UZ\" \"VZ\" \"WZ\" \"XZ\" \"YZ\" \"ZZ\"\n\n\nThe head() and tail() functions are very useful for inspecting the beginning and the end of a very large object such as a vector, matrix, or data frame. They are very useful for checking if the operation you just performed did what you expected it to do.\n\n\n\n\n\n\n\nExercise 2.1 (Creating column names) Repeat the procedure above, but generate column names for a matrix with more than a 1000 columns. Use the LETTERS constant, but rather then generating two-letter column names, generate three-letter column names: AAA, AAB, AAC, …, ABA, ABC, …, ZZZ. Store the result in a variable called col_names.\n\n\n\n\n\n\n\n\n\n\n\nExercise 2.2 (Matrices - accessing and changing elements) Assume you have a 48 well-plate for a drug sensitivity analysis with viability scores.\n\nCreate a 48-element vector “drugSensitivity_v” with random numbers between 0 and 1. Use runif(48) to generate these values. These reflect your viability scores.\nWhat does the runif() function do?\nCreate a 6x8 matrix “drugSensitivity” from the vector.\n\nBefore starting you experiment, you decided to leave out the border wells to avoid edge effects:\n\nChange the values of all the border elements to NA.\n\nThe rows are treated with inhibitor 1 with increasing concentrations (control, low, medium, high). Columns 2 to 4 are treated with inhibitor 2 with increasing concentrations (control, low, high) and column 5 to 7 are treated with inhibitor 3 (same concentrations as inhibitor 2).\n\nUse row and column names to reflect treatments.\nWhat are potential problems of this approach?\nSelect all wells with inhibitor 3.\nWhich wells can be used as negative control?\nSelect only wells with a combination of inhibitor 1 and inhibitor 2.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex data structures</span>"
    ]
  },
  {
    "objectID": "day2-complex-structures.html#lists",
    "href": "day2-complex-structures.html#lists",
    "title": "2  Day 2: Complex data structures",
    "section": "2.4 Lists",
    "text": "2.4 Lists\n\n2.4.1 Creating lists\nThe objects that we have discussed so far – vectors and matrices – can only hold one type of data; you cannot mix strings with numbers, for example. This is obviously a problem – quite frequently you need to store both numbers and strings in one object. This is where lists come in.\nLists are created using the list() function. Lists have elements, just like vectors; but unlike vectors, every element can be of any possible type. It can be a vector, of course, but can also be a matrix, a data frame, even a function – or another list. Actually, it is quite common to have a list of lists (or even list of lists of lists) in R.\n\nlst &lt;- list(numbers=1:3, strings=c(\"a\", \"bu\"), \n            matrix = matrix(1:4, nrow = 2), \n            logical = c(TRUE, FALSE))\nlst\n\n$numbers\n[1] 1 2 3\n\n$strings\n[1] \"a\"  \"bu\"\n\n$matrix\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n$logical\n[1]  TRUE FALSE\n\n\n\n\n2.4.2 Accessing elements of a list\nLike vectors, lists can be named. In fact, they very often are. However, accessing them is a bit different than with vectors.\nYou can use [ and ] square brackets to access elements of a list, but this produces another list, containing only the selected elements. Thus, if you type lst[\"numbers\"], you will get a list with one element, which is the vector of numbers:\n\nlst[\"numbers\"]\n\n$numbers\n[1] 1 2 3\n\n\nYou can see that it is a list because of this weird $ (dollar) sign, which we will discuss in a moment. However, you can also check its type directly:\n\ntypeof(lst[\"numbers\"])\n\n[1] \"list\"\n\n\nIf, however, you want to work with the actual vector that is stored in the “numbers” slot of the list, you need to use one of two approaches. First approach is to use double square brackets:\n\nlst[[\"numbers\"]]\n\n[1] 1 2 3\n\ntypeof(lst[[\"numbers\"]])\n\n[1] \"integer\"\n\n\nThat requires a lot of typing, four times square brackets and then, in addition, the quote marks. But programmers are lazy, and therefore, we have a shortcut: the $ sign. It is used to access elements of a list by name:\n\nlst$numbers\n\n[1] 1 2 3\n\n\nYou will use this construct a lot in R.\nThe elements of a list behave exactly like regular variables. If an element is a vector, you can do with it all the things you can do with a vector; if it is a matrix, you can treat is as a matrix (because it is a matrix).\n\npatient_data &lt;- list(name = \"John Doe\", age = 42, \n                     measurements = runif(5))\npatient_data\n\n$name\n[1] \"John Doe\"\n\n$age\n[1] 42\n\n$measurements\n[1] 0.2536847 0.3608098 0.7842325 0.9418489 0.6641299\n\npatient_data$measurements[1]\n\n[1] 0.2536847\n\npatient_data$measurements[1] &lt;- 42\npatient_data$measurements * 3\n\n[1] 126.000000   1.082429   2.352698   2.825547   1.992390\n\n\nSince the lists are named, there must be a way to access and modify these names. And, of course, there is: the names() function.\n\nnames(patient_data)\n\n[1] \"name\"         \"age\"          \"measurements\"\n\nnames(patient_data) &lt;- c(\"patient_name\", \"patient_age\", \"patient_measurements\")\nnames(patient_data)[3] &lt;- \"crp_measurement\"\n\n\n\n\n\n\n\nTab completion with lists and data frames\n\n\n\nIf you type the name of your data frame variable in a script, the $ and press the TAB key, RStudio will show you all the elements of a list (or columns of the data frame) to choose from. No need for tedious typing!\n\n\n\n\n2.4.3 Lists as return values\nA common application of lists has something to do with functions. Remeber that a function can return only one object? But what if a function would like to return several things at once? It can return a list!\nWe will run now our first statistical test. First, we need to generate two groups of measurements to compare. We will simulate them using the rnorm() function which produces normally distributed random numbers. The function takes additional parameters, mean and sd, which specify the mean and the standard deviation of the distribution, respectively. That allows us to ensure that the groups differ:\n\ngroup_a &lt;- rnorm(10, mean = 10, sd = 2)\ngroup_b &lt;- rnorm(10, mean = 14, sd = 2)\n\nOf course, before running any statistical test we usually want to have a look at the data, to see if the groups differ visually. We can do this by using the boxplot() function, which creates a boxplot of the data.\n\nboxplot(group_a, group_b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBoxplot\n\n\n\nBoxplots are a great way to visualize the data. The whiskers show the minimum and maximum values (excluding outliers, which are shown as separate points), the box shows the interquartile range (25th to 75th percentile), and the thick line in the middle of the box shows the median. There are better ways, which we will discuss on Day 5, but still, boxplots are pretty cool.\n\n\nOK, now we run a t-test. We will use the t.test() function for that, and store the result in a variable called t_test.\n\nt_test &lt;- t.test(group_a, group_b)\ntypeof(t_test)\n\n[1] \"list\"\n\nt_test\n\n\n    Welch Two Sample t-test\n\ndata:  group_a and group_b\nt = -3.5678, df = 15.71, p-value = 0.002633\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -6.574517 -1.668989\nsample estimates:\nmean of x mean of y \n 9.849202 13.970955 \n\n\nAs you can see, the result is a list. However, when we print it to the console, it does not look like one. This is because R has a special function for formatting the results of a t-test2, so that it is easier to read.\nNonetheless, we can access the elements of the list in the usual way:\n\nt_test$p.value\n\n[1] 0.002632791\n\n\n\n\n2.4.4 Replacing, adding and removing elements of a list\nYou can assign elements to a list using the $ sign. If the element does not exist yet in the list, it will be created; if it does, it will be replaced.\nTo remove an element, you need to use the special value NULL.\n\nperson &lt;- list(name = \"January\", age = 117, pets=c(\"cat\", \"dog\"))\n\n# change the age\nperson$age &lt;- 118\n\n# add a new element\nperson$city &lt;- \"Hoppegarten\"\n\n# remove pets\nperson$pets &lt;- NULL\nperson\n\n$name\n[1] \"January\"\n\n$age\n[1] 118\n\n$city\n[1] \"Hoppegarten\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex data structures</span>"
    ]
  },
  {
    "objectID": "day2-complex-structures.html#data-frames",
    "href": "day2-complex-structures.html#data-frames",
    "title": "2  Day 2: Complex data structures",
    "section": "2.5 Data Frames",
    "text": "2.5 Data Frames\n\n2.5.1 Creating data frames\nFinally, we come to possibly the most important data structure in R – at least for us, biologists and medical researchers: data frames. Data frames are the closest thing to an Excel spreadsheet in R. They are used to store data in a tabular form, where each column can be of a different type. This makes them perfect for storing data from experiments, clinical trials, etc. You will be using them a lot.\nIn R, data frames are lists that were made to behave a lot like matrices. Thus, everything that you learned so far about lists can be applied to data frames, including accessing their elements (columns) using the $ operator. However, there are some differences between data frames and matrices.\nThe main feature of data frame that makes them a bit like matrices is the fact that each element of a data frame is a vector3 and that these vectors have always the same length. This means that one of the major differences between data frames and, say, Excel spreadsheets, is that a column of a data frame contains only elements of a single type. If a “cell” in a data frame is a character string, then the whole column is a character vector; if it is numerical, then the whole column is a numerical vector, etc.\nThis may seem like a limitation, but it is, in fact, a good thing. It makes data more consistent and less prone to errors.\nLike lists, data frames can be named or not, but typically they are. The names of a data frame are precisely the column names and you can access them (and modify) using both, names and colnames functions.\n\nnames &lt;- c(\"January\", \"William\", \"Bill\")\nlastn &lt;- c(\"Weiner\", \"Shakespeare\", \"Gates\")\nage   &lt;- c(NA, 460, 65)\n\npeople &lt;- data.frame(names=names, last_names=lastn, age=age)\npeople\n\n    names  last_names age\n1 January      Weiner  NA\n2 William Shakespeare 460\n3    Bill       Gates  65\n\nnames(people)\n\n[1] \"names\"      \"last_names\" \"age\"       \n\ncolnames(people)\n\n[1] \"names\"      \"last_names\" \"age\"       \n\n\nLike matrices, data frames have dimensions, which you can access using the dim(), nrow() and ncol() functions.\n\ndim(people)\n\n[1] 3 3\n\nnrow(people)\n\n[1] 3\n\nncol(people)\n\n[1] 3\n\n\nAlso, like matrices, the data frames can have rownames; however, for reasons that will be clear later, they are not as important as column names and in fact, we will not be using them4.\n\n\n\n\n\n\n\nExercise 2.3  \n\nCreate a 5x3 matrix with random numbers. Use matrix and rnorm.\nTurn the matrix into a data frame. Use as.data.frame for that.\nAdd column and row names.\nAdd a column. Each value in the column should be “A” (a string). Use the rep function for that.\nAdd a column with five numbers from 0 to 1. Use the seq function for that. Hint: look at the help for the seq function (?seq).\n\n\n\n\n\n\n\n2.5.2 Accessing and modifying columns of a data frame\nSince data frames are lists, you can access their columns using the $ operator. This is the most common way of accessing columns of a data frame:\n\npeople$names\n\n[1] \"January\" \"William\" \"Bill\"   \n\n\nYou can also access columns using the square brackets, just like with matrices, using a comma to denote the columns and rows. However, there is a fine difference between matrices and data frames: if you select a single row, you will not get a vector, but a data frame with one row. If you think about that, it makes perfect sense: the different columns can have different data types, so they cannot be easily combined into a vector without losing some information.\n\npeople[1, ]\n\n    names last_names age\n1 January     Weiner  NA\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThere is an issue when you try to access a single column of a data frame. We will discuss it at length in the following, but basically, this behavior is different for different flavors of data frames: base R data frames created with data.frame() return a vector, while others may return a data frame. Watch out for this!\n\n\n\n\n2.5.3 Subsetting data frames with logical vectors\nJust like with vectors, you can use logical vectors to subset data frames. This is extremely useful and very common in R. For example, we might want to select only rows that do not contain NA values in the age column.\n\npeople_with_age &lt;- people[!is.na(people$age), ]\npeople_with_age\n\n    names  last_names age\n2 William Shakespeare 460\n3    Bill       Gates  65\n\n\nThat way we have filtered the data frame, leaving only persons with known age.\nActually, for data frames, you will commonly use the filter() function (which we will introduce tomorrow). However:\n\nthe filter() function also uses logical vectors;\nyou can subset many different data types using logical vectors (including matrices, lists, vectors, data frames), but filter() works only with data frames; and\nsometimes using logical vectors is just more convenient.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex data structures</span>"
    ]
  },
  {
    "objectID": "day2-complex-structures.html#libraries-in-r",
    "href": "day2-complex-structures.html#libraries-in-r",
    "title": "2  Day 2: Complex data structures",
    "section": "2.6 Libraries in R",
    "text": "2.6 Libraries in R\n\n2.6.1 Installing and loading packages\nStarting tomorrow, we will cease to only use “base” R functions (that is, functions that are available in R “out of the box”) and start using additional packages. Packages in R are collections of functions (and often some other things, like data sets, documents and more).\nPackages need to be installed before they can be used – but once you have installed a package, you don’t need to install it again (unless you upgrade R or want to update the package to a newer version).\nHowever, to use a package, you also need to load it using the library() function. This you must do every time you start a new R session, because R “forgets” which packages have been loaded the previous time. It is a bit like with the software for your operating system: you need to install your browser only once, but you have to start each each time after you start your computer.\nInstalling packages usually is straightforward, however at times it can be tricky.\n\n\n\n\n\n\npackage ‘—’ was built under R version x.y.z\n\n\n\nAt times you will get a warning that a package was “built” under a different version of R than the one that you are running. It is not an error (just a warning), and most of the time it can be ignored. It means what it says: that the installed package was built (e.g., compiled) with a different version of R. This can sometimes lead to problems, but most of the time it does not.\n\n\nWe will return to installing packages from different sources on Day 5.\n\n\n\n\n\n\nRemember!\n\n\n\nRemember: you need to install a package only once with install.package(), but you need to load it every time you start a new R session with library().\n\n\n\n\n\n\n\n\n\nExercise 2.4 Use install.packages to install the package colorDF from CRAN. Then, load the package using library(colorDF). What does that package do? How can you check that? (Hint: use ??colorDF).\n\n\n\n\n\n\n2.6.2 Data frames, tibbles & co.: different flavors of R\nIt is now time to reveal some ugly truths about R. R is open source, and everyone can modify it, add new packages etc. This is great and resulted in the vibrant user community that R has. Also, there is hardly a statistical method or framework that is not represented in R. In addition, developing and publishing new packages for R is incredibly easy, at least compared to some other languages.\nHowever, this has a downside. There are many different flavors of R, and, unfortunately, some of the most popular packages or groups of packages can clash. We will spend now some time with one particular example: data frames. Firstly, because you will be using data frames a lot, secondly, because it neatly illustrates the problem, and thirdly to introduce a new type of data – tibbles.\nBase R data frames are created using the data.frame() function. They are useful and we use them a lot, but they have one tiny inconsistency that can cause a lot of trouble. Say, you define your data frame like this:\n\ndf &lt;- data.frame(a = 1:3, b = c(\"a\", \"b\", \"c\"))\n\nWhen you access a single column of this data frame using the square brackets [ ], you will get a vector. We can check it with the is.data.frame() function:\n\nis.data.frame(df[ , 1])\n\n[1] FALSE\n\n\nThis is consistent with the behavior of matrices (where one column or one row becomes a vector), but not with the behavior of the data frames themselves: because when you access a single row, you are getting a data frame, not a vector:\n\nis.data.frame(df[1, ])\n\n[1] TRUE\n\n\nThis inconsistency can mess up your code. Imagine that you have somehow automatically selected some columns of a data frame – for example, by selecting columns that start with a certain letter (we will learn how to do that on Day 4). You store it in the variable called sel_cols. You can select the columns from the data frame using the df[ , sel_cols] syntax. However, depending on whether there was a single column selected or more, you will get either a vector or a data frame. This is annoying and in the worst case scenario, it can break your program.\nMany people noticed this, and proposed solutions. In R, it is possible to take a class of an object (like data.frame) and modify it. One of such most commonly used modifications is called a tibble and has been implemented in the Tidyverse group of packages, which we will be using extensively in the days to come.\n\n\n2.6.3 Data frames and tibbles\nThe Tidyverse data frame is called a tibble. It behaves almost exactly like a data frame, with a few crucial differences:\n\nwhen printing the tibble to the console, the output is nicer\ntibbles never have row names (and that is why we will not be using them)\nwhen you access a single column of a tibble, you always get a tibble, not a vector\n\nTo use tibbles, you need the tidyverse package5. You can install it using install.packages(\"tidyverse\") and load it using library(tidyverse).\n\nlibrary(tidyverse)\ntbl &lt;- tibble(a = 1:3, b = c(\"a\", \"b\", \"c\"))\ntbl\n\n# A tibble: 3 × 2\n      a b    \n  &lt;int&gt; &lt;chr&gt;\n1     1 a    \n2     2 b    \n3     3 c    \n\nis.data.frame(tbl)\n\n[1] TRUE\n\nis_tibble(tbl)\n\n[1] TRUE\n\n\nAs you can see, a tibble is both a data frame and a tibble. You can use tibbles as a drop-in replacement for data frames. We will be seeing it a lot, because many useful functions from the Tidyverse family produce tibbles, not data frames. However, for you, as the user, the differences will be mostly cosmetic. So far, so good.\nHowever, if you are reading this book, chances are that you are a biologist or medical researcher, and that means that sooner or later you will be using packages from the Bioconductor project. Bioconductor is a collection of R packages for bioinformatics, genomics, and related fields. They are incredibly valuable, you can hardly do bioinformatics without them. However, Bioconductor defines its own alternative to data.frames, called DataFrame. It is a bit different from data frames, and it is not compatible with tibbles. If you want to process DataFrames produced by Bioconductor packages with Tidyverse functions, you need to convert them to a regular data.frame using the as.data.frame() function.\nThe code below will not work until you install the Bioconductor package S4Vectors. Don’t worry if it does not work – we will not be using Bioconductor in this course, but I wanted to show you where the problem is.\n\nlibrary(S4Vectors)\nDF &lt;- DataFrame(a = 1:3, b = c(\"a\", \"b\", \"c\"))\nDF\n\nDataFrame with 3 rows and 2 columns\n          a           b\n  &lt;integer&gt; &lt;character&gt;\n1         1           a\n2         2           b\n3         3           c\n\nis.data.frame(DF)\n\n[1] FALSE\n\n\nAs you can see, the DataFrame object is not a data.frame. And this means that the Tidyverse function filter() does not see it as one (you will learn about the filter() function on Day 4):\n\nlibrary(tidyverse)\nfilter(DF, a &gt; 1)\n\nError in UseMethod(\"filter\"): no applicable method for 'filter' applied to an object of class \"c('DFrame', 'DataFrame', 'SimpleList', 'RectangularData', 'List', 'DataFrame_OR_NULL', 'Vector', 'list_OR_List', 'Annotated', 'vector_OR_Vector')\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex data structures</span>"
    ]
  },
  {
    "objectID": "day2-complex-structures.html#summary",
    "href": "day2-complex-structures.html#summary",
    "title": "2  Day 2: Complex data structures",
    "section": "2.7 Summary",
    "text": "2.7 Summary\nThings you learned today:\n\nLogical vectors:\n\nsubsetting with logical vectors\nusing comparison operators like &gt; to create logical vectors\nusing the is.na() function to check for NA values\nusing the which() function to find the positions of TRUE values\nusing the ! operator to negate logical vectors\n\nMatrices:\n\ncreating matrices using the matrix() function\nmeasuring matrices with dim(), nrow() and ncol()\nrows first, then columns\naccessing elements, rows, columns and submatrices of a matrix\nnaming rows and columns of a matrix\n\nLists:\n\ncreating lists using the list() function\naccessing elements of a list using [, [[ and $\nlists as return values from functions\nreplacing, adding and removing elements of a list\n\nData frames:\n\ncreating data frames using the data.frame() function\naccessing and modifying column names of a data frame\naccessing and modifying elements of a data frame\nsubsetting data frames\nadding and removing columns from a data frame\nmerging data frames\ncreating tibbles with Tidyverse and tibble()\n\nOther:\n\nconstant vectors LETTERS and letters\nusing the rep() function\ngenerating random numbers with rnorm() and runif()\ngenerating sequences with seq()\nrunnning a t-test using function t.test()\nmaking a boxplot with boxplot()\nthe special value NULL\nconverting matrices to data frames with as.data.frame()\ninstalling packages with install.packages()\nloading packages with library()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex data structures</span>"
    ]
  },
  {
    "objectID": "day2-complex-structures.html#footnotes",
    "href": "day2-complex-structures.html#footnotes",
    "title": "2  Day 2: Complex data structures",
    "section": "",
    "text": "Actually, they can be used to compare any two objects in R. Also, the &gt; and &lt; operators can be used to compare strings, but the result is not always what you might expect. Can you guess what it does? Hint: pick up a dictionary… or any other alphabetically sorted list.↩︎\nOK, this is way beyond the scope of this course, but the result returned by t.test has the class “htest”. This is a list, but also it is something special, which is why R knows to print it in a different way. R is a functional language, but it also allows object oriented (OO) programming.↩︎\nActually, it is a bit more complicated than that, but for now, let’s just say that each column of a data frame is a vector.↩︎\nRow names in R data frames are very old school. Many people still use them, and many R functions produce them. However, we will be using the packages from the tidyverse family further down the line, which ignore the rownames, and for good reasons.↩︎\nActually, the tidyverse package is a meta-package: it just loads a collection of packages that are often used together. The tibble package which defines tibbles is one of them.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex data structures</span>"
    ]
  },
  {
    "objectID": "day2-complex-structures.html#review",
    "href": "day2-complex-structures.html#review",
    "title": "2  Day 2: Complex data structures",
    "section": "2.7 Review",
    "text": "2.7 Review\nThings you learned today:\n\nLogical vectors:\n\nsubsetting with logical vectors\nusing comparison operators like &gt; to create logical vectors\nusing the is.na() function to check for NA values\nusing the which() function to find the positions of TRUE values\nusing the ! operator to negate logical vectors\n\nMatrices:\n\ncreating matrices using the matrix() function\nmeasuring matrices with dim(), nrow() and ncol()\nrows first, then columns\naccessing elements, rows, columns and submatrices of a matrix\nnaming rows and columns of a matrix\n\nLists:\n\ncreating lists using the list() function\naccessing elements of a list using [, [[ and $\nlists as return values from functions\nreplacing, adding and removing elements of a list\n\nData frames:\n\ncreating data frames using the data.frame() function\naccessing and modifying column names of a data frame\naccessing and modifying elements of a data frame\nsubsetting data frames\nadding and removing columns from a data frame\nmerging data frames\ncreating tibbles with Tidyverse and tibble()\n\nOther:\n\nconstant vectors LETTERS and letters\nusing the rep() function\ngenerating random numbers with rnorm() and runif()\ngenerating sequences with seq()\nrunnning a t-test using function t.test()\nmaking a boxplot with boxplot()\nthe special value NULL\nconverting matrices to data frames with as.data.frame()\ninstalling packages with install.packages()\nloading packages with library()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex data structures</span>"
    ]
  },
  {
    "objectID": "day1-intro-to-r.html",
    "href": "day1-intro-to-r.html",
    "title": "1  Day 1: Introduction to R",
    "section": "",
    "text": "1.1 Goals for today\nWhat you should know after today:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "day1-intro-to-r.html#goals-for-today",
    "href": "day1-intro-to-r.html#goals-for-today",
    "title": "1  Day 1: Introduction to R",
    "section": "",
    "text": "what is R?\nwhy use R?\nfirst steps in R\n\n\n\nwhat R is\nhow to start R\nhow to use R as a calculator\nhow to assign variables\nhow to use functions\nhow to use vectors\nhow to use data frames\nhow to use packages",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "day1-intro-to-r.html#r-rstudio-and-other-languages",
    "href": "day1-intro-to-r.html#r-rstudio-and-other-languages",
    "title": "1  Day 1: Introduction to R",
    "section": "1.2 R, RStudio and other languages",
    "text": "1.2 R, RStudio and other languages\n\n1.2.1 Why R?\n\n\n1.2.2 R and RStudio\nR is the name of both, the programming language and of the language interpreter. When you start RStudio, you can see the R language interpreter working in the part of the window left and bottom - called “console”. So yes, you don’t need RStudio to work with R and, in fact, many people prefer to work with R in a different environment.\nRStudio is a so called IDE, an Integrated Development Environment. That is, it provides a lot of goodies that help make your work easier, faster and more efficient.\n\n\n1.2.3 R and other languages\nR is not the only language that you can use for data analysis. There are many other languages that are used for this purpose, including Python, Matlab and many others. Each of these languages has its own strengths and weaknesses, and the choice of language depends on your needs. In fact, most bioinformaticians know more than one language, and use the one that is best suited for the task at hand.\nWe think that R is a particularly good choice for all those who just need a tool to use from time to time to help them with their work. It is relatively easy to learn, and it is very powerful. However, other choices are also worth mentioning.\nMatlab is a language that is in many ways similar to R. The main differnce is maybe that unlike R, Matlab is not free – it is closed source and you have to pay for a license. This has some advantages. For example, and as you will see during this course, R development is not centralized and so there are many packages that do the same thing. Matlab is in some aspects more consistent and more polished than R, and in some comparisons appears to be faster – and for this, it is often the language of choice for areas such as image analysis.\nPython is completely different story. This is a powerful, fast, general purpose programming language. It is more versatile than R, has a much more standardized syntax and development process. However, it is harder to learn and it is not really meant to be used interactively (although it can be – especially when combined with Quarto or Jupyter Notebook). While many statistical modules exist for Python, it is not as strong in this area as R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "day1-intro-to-r.html#projects-and-workspaces",
    "href": "day1-intro-to-r.html#projects-and-workspaces",
    "title": "1  Day 1: Introduction to R",
    "section": "1.3 Projects and Workspaces",
    "text": "1.3 Projects and Workspaces\n\n1.3.1 Creating a project: start here!\nWhen starting work with a new project, do the following: (i) create a new directory for the project, (ii) open an R script file and save it in the directory you created and (iii) copy necessary data files.\nTo create a new directory in RStudio, go to File -&gt; New Project. When the dialog window appears, select first “New Directory” and then “New Project”. Select the location where you would like to have the directory created and click on “Create Project”.\n\n\n\n\n\n\n\nExercise 1.1  \n\nCreate a new project in RStudio. Do it now, you will continue to work with this project over the next few days (we hope).\nInspect the contents of the project directory. What files are there?\n\n\n\n\n\nWhen Rstudio creates a new project, it creates a new directory with the same name as the project. Furthermore, it creates a new file in this directory called projectname.Rproj. This file is used by RStudio to keep track of project-specific settings.\nYou can open this file by double-clicking on it in the Files pane in RStudio. Like most of the files that you will be working with, it is a simple text file: you can open it in any text editor, including RStudio.\nLater on, if you choose to do so, R can create two hidden files, Rhistory (called .Rhistory on Unix-like systems and _Rhistory on Windows) and .RData (or _RData). This files save the state of your R session (of your R workspace, to be specific).\n\n\n1.3.2 Workspaces, history and environments\n\n\n1.3.3 Tab completion",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "day1-intro-to-r.html#lets-start-with-r",
    "href": "day1-intro-to-r.html#lets-start-with-r",
    "title": "1  Day 1: Introduction to R",
    "section": "1.4 Let’s start with R",
    "text": "1.4 Let’s start with R\n\n1.4.1 R as a calculator\nYou can use R as a very powerful calculator. For example, do you want to know what \\(\\sin(\\pi/2)\\) is? Just type sin(pi/2) in the console and press Enter. Addition and subtraction work, as expected, with + and -. To multiply two numbers, type 2*3; to divide, type 2/3. You can get exponents (powers, eg. \\(2^3\\)) by typing 2^3. If the ^ symbol (called “caret”) is not available on your keyboard, you can use ** instead. Parentheses () are used to group expressions, just like in mathematics. To logarithmize, you can use log(), log2() and log10() functions. For example, to calculate \\(\\log_{10}(100)\\), type log10(100). Can you guess how to calculate \\(\\sqrt{2}\\)? Yes, you are right: sqrt(2). Or 2^(1/2), that will also do.\n\n\n\n\n\n\n\nExercise 1.2 Calculate the following expressions in R:\n\n\\(\\log_{2}(8)\\)\n\\(\\sin(\\pi)\\)\n\\(2^{10}\\)\n\\(\\sqrt{e}\\)\n\n\n\n\n\n\n\n1.4.2 Using script files\nOn the left side of the RStudio window you have (by default) two panels: the lower one is called “Console”. When you create a new script file, it appears above.\n\n\n\n\n\n\nTyping in console\n\n\n\nYou can type your commands (properly called “expressions”) directly into the console, but it is generally not a good idea. Why? The truthful answer is: because it is messy and sooner or later you will regret it. You can save the history of what you type in the console, but it is easier (and cleaner) to save your program in a script file.\n\n\nWhen you open or create an R script file and type something into it, you can run it by pressing Ctrl+Enter (or Cmd+Enter on Mac). This will send the line of code to the console, where it will be executed. You can also select a fragment of the code before you press Ctrl+Enter, and then the whole selected fragment will be sent to the console.\nHowever, if you start your line with #, it will not be executed. This is called a comment and we will spend some time later on convincing you that you should use a lot of comments in your code.\n\n\n\n\n\n\n\nExercise 1.3 Repeat Exercise 1.2, but now type the expressions into the script which you have created in Exercise 1.1. Run the script by pressing Ctrl+Enter after each line.\n\n\n\n\nScript files are also text documents. You can open them in any text editor, for example Notepad or even Word (but don’t do that). In RStudio, you see the script file in many colors: for example, comments can be green, strings (text in quotes) can be red, and so on. This is called syntax highlighting and is done by RStudio to make your code more readable. You will not see the colors when you open your R script in Notepad.\n\n\n\n\n\n\nImportant\n\n\n\nFrom now on, you should only type your code in script files.\n\n\n\n\n1.4.3 Variables\nWhat if we want to store the result of a calculation for later use? We can do this by assigning the result to a variable. In R, you assign a value to a variable using the &lt;- operator:\n\nx &lt;- 2\ny &lt;- sin(pi/2)\nz &lt;- x + y\n\nIf you want to see the value of a variable, just type its name in the console and press Enter, or use print() function:\n\nprint(z)\n\n[1] 3\n\n\n\n\n\n\n\n\nAssignment operator\n\n\n\nMany other languages use = as an assignment operator. In R, you can use = as well, but do yourself a favour and don’t. Use &lt;- instead. Why? Your code will be more readable and you will avoid many common mistakes.\n\n\nVariables are like boxes in which you can store values. However, unlike boxes, when you assign one variable to another, the first variable keeps its content:\n\nx &lt;- 2\ny &lt;- x\nprint(x)\n\n[1] 2\n\n\nWe now come to a very important point which we will revisit often, as it is one of the most common beginner (and not only beginner) mistakes. When you forget to assign the value to a variable, R will print it to the console, but the variable will not be modified:\n\nx &lt;- 2\n# prints 0.9092974:\nsin(x) \n# prints 2\nprint(x) \n\nIn the code above, the value of x is not changed by the sin() function. To store the value of a function, you need to assign it to a variable:\n\nx &lt;- 2\n# does not print anything:\nx &lt;- sin(x) \n# prints 0.9092974:\nprint(x)    \n\nPlease spend some time on this, as it is a very common source of errors.\n\n\n\n\n\n\nImportant\n\n\n\nAs a rule of thumb1, if the expression you type in your script does not contain the &lt;- operator, it will not modify any variables.\n\n\n\n\n\n\n\n\n\nExercise 1.4 Create a variable using x &lt;- 42. Take a look at the Environment pane in RStudio (top left part of the window). Do you notice anything?\n\n\n\n\n\n\n1.4.4 Character variables\nVariables can store not only numbers, but also text. Text in R is called a character string. To create a character string, you need to enclose the text in quotes (both single and double quotes are allowed, but try to be consistent and use only one type). For example:\n\nname &lt;- \"January\"\ncity &lt;- \"Hoppegarten\"\ngreeting &lt;- \"Hello, world!\"\n\nCharacter variables cannot be used with algebraic computations, the following code will throw an error:\n\n# this does not work!\nname + city\n\nHowever, if you want to “add” two character strings (that is, concatenate them), you can use the paste() function:\n\npaste(name, city)\n\n[1] \"January Hoppegarten\"\n\n\nQuite often, you don’t want to have a space between the two strings. This is such a common operation that R has a shortcut for it:\n\npaste0(name, city)\n\n[1] \"JanuaryHoppegarten\"\n\n\n\n\n\n\n\n\nOther types\n\n\n\nThere are other types of data types in R. Later on, we will briefly touch on factors, which look like character strings but behave like numbers. Another important data type is a logical type, which can have only two values: TRUE and FALSE. We will talk about logical types in more detail tomorrow. And under the hood, numeric vectors can be either integers (numbers like 1, 2, …) or floating point numbers (numbers like 1.1, 2.2 or \\(\\pi\\)).\n\n\n\n\n\n\n\n\n\nExercise 1.5 (Variables) Create the following variables in your script:\n\nname with the value of your first name\ncity with the value of the city where you live\nage with the value of your age\ngreeting with the value “Hello,”\nconcatenate the variables greeting and name and store the result in a new variable message",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "day1-intro-to-r.html#vectors-and-vectorization",
    "href": "day1-intro-to-r.html#vectors-and-vectorization",
    "title": "1  Day 1: Introduction to R",
    "section": "1.5 Vectors and vectorization",
    "text": "1.5 Vectors and vectorization\n\n1.5.1 Vectors\nVariables can (and do) store a lot more than single values. One of the most basic and important data types in R is a vector. A vector is simply a sequence of values – just like in maths. And you know what? You have already created vectors in R. In mathematics, any scalar value can be treated as a one-dimensional vector and it is exactly like that in R: any single value is a 1-element vector, including all the variables that you have created in the previous exercise.\nTo create a vector with more than one value, you can use the c() function (“c” stands for “combine”). For integer numbers, you can use the : operator to create a sequence of numbers. For example:\n\nsequence &lt;- 5:15\nnumbers &lt;- c(10, 42, 33, 14, 25)\nperson &lt;- c(\"January\", \"Weiner\", \"Hoppegarten\")\n\nIt is also possible to combine two vectors longer than 1 into one:\n\nfirst_v &lt;- c(1, 2, 3)\nsecond_v &lt;- c(4, 5)\ncombined_v &lt;- c(first_v, second_v)\nprint(combined_v)\n\n[1] 1 2 3 4 5\n\n\nYou can access individual elements of a vector using the [ ] operator:\n\nnumbers[1]\n\n[1] 10\n\nperson[2]\n\n[1] \"Weiner\"\n\n\nBut hey, I told you that every value is a vector in R, right? And that includes the indices 1 and 2 that you have just used. So, what would happen if we used more than two values as an index? Try it:\n\nnumbers[1:3]\n\n[1] 10 42 33\n\nperson[3:1]\n\n[1] \"Hoppegarten\" \"Weiner\"      \"January\"    \n\nsel &lt;- c(1, 5, 3)\nnumbers[sel]\n\n[1] 10 25 33\n\n\nAs you can see, not only can you use a vector as an index, but you can also use a variable as an index.\n\n\n\n\n\n\nDo not use a comma\n\n\n\nIt is tempting to select, say, first and the third element of a vector numbers by writing numbers[1, 3]. This will not work! As you will see tomorrow, this way of writing is for two-dimensional objects. You must use a vector as an index: numbers[c(1, 3)].\n\n\n\n\n\n\n\n\nVectors and indices\n\n\n\nIn many (most?) programming languages, the first element of a vector is accessed using the index 0. For example in Python, to access the first element of an array, you need to type array[0]. This has something to do with how computers work. In R, the first element is always 1 – R was designed by statisticians, and in mathematics we always start counting from 1. For some reason, this seems to make some computer scientists angry.\n\n\n\n\n1.5.2 Named vectors\nAccessing elements of a vector using indices is all well and good, but sometimes it can be very inconvenient, especially if the vectors are very long. Or maybe you do not remember the order in which you have stored the elements of the vector – was the last name first, or second element of the person vector?\nVectors allow you to name their elements. We can either define the names at the very beginning, when we create the vector, or we can add them later using the names() function. Here is how you can do it:\n\nperson &lt;- c(first=\"January\", last=\"Weiner\", city=\"Hoppegarten\")\n\nOnce you have named the elements of a vector, you can access them using their names:\n\nperson[\"city\"]\n\n         city \n\"Hoppegarten\" \n\nperson[c(\"first\", \"last\")]\n\n    first      last \n\"January\"  \"Weiner\" \n\n\n\n\n1.5.3 Assigning values to selected elements\nOK, one more thing about vectors. Above we have selected elements from a vector. It turns out, we can do more with that selections then just print it to a console:\n\nnumbers &lt;- c(10, 42, 33, 14, 25)\nsel &lt;- c(1, 5)\nnumbers[sel] &lt;- c(100, 500)\nnumbers\n\n[1] 100  42  33  14 500\n\n\nHere is what happened: we assigned new values to the first and the fifth element of the vector numbers. This is a very powerful feature of R and you will be using it a lot.\n\n\n\n\n\n\n\nExercise 1.6 (Accessing and modifying vectors)  \n\nCreate a vector with the first 10 prime numbers. Call it primes.\nHow do you access the 3rd, 5th and 7th prime number?\nWhat happens when you do primes[11]?\nWhat happens when you do primes[11] &lt;- 11?\nWhat happens when you do primes[-1]?\nChange the 3rd, 5th and 7th prime number to 100, 500 and 700, respectively.\n\n\n\n\n\n\n\n1.5.4 Vectorization\nVectors are very useful – but wait, there is more. What happens if we add a value to a vector? Try it:\n\nnumbers &lt;- c(10, 42, 33, 14, 25)\nnumbers + 10\n\n[1] 20 52 43 24 35\n\n\nAs you can see, R has added the value 10 to every single element of the vector numbers. The same thing happens with other operators, like -, * and /. Try it yourself.\nThis is called vectorization and it is one of the most powerful features of R compared to other languages. It will allow you to write very concise and, at the same time, readable code.\nThe vectorization works not only with operators like +, -, * and /, but with many functions. For example, it works with most of the mathematical functions like sin() or log(). Try it:\n\nlog10(numbers)\n\n[1] 1.000000 1.623249 1.518514 1.146128 1.397940\n\nsin(numbers)\n\n[1] -0.5440211 -0.9165215  0.9999119  0.9906074 -0.1323518\n\n\nHowever, there is a catch. What happens if you try to add two vectors when both of them with more than one element? First, let us try to add two vectors of the same length:\n\nnumbers1 &lt;- c(1, 2, 3)\nnumbers2 &lt;- c(4, 5, 6)\nnumbers1 + numbers2\n\n[1] 5 7 9\n\n\nAs you can see, R has added the first element of the first vector to the first element of the second vector, the second element of the first vector to the second element of the second vector, and so on. Makes sense, right? Same would happen if we were to subtract, multiply or divide the vectors (or use logical operations, which you will learn on Day 3). This does not look like much now, but trust me, it will be extremely useful in the future.\nHowever, if the vectors have different lengths, it is a different story altogher. Take a look:\n\nnumbers1 &lt;- c(1, 2, 3)\nnumbers2 &lt;- c(4, 5)\nnumbers1 + numbers2\n\nWarning in numbers1 + numbers2: longer object length is not a multiple of shorter object length\n\n\n[1] 5 7 7\n\n\nOoops, what exactly happened here? First thing to note is that there was no error. There was a warning, but still our code executed and produced a result. But what is that result? For the first element of the result, it is clear enough: 1 + 4 = 5. Same for the second, 2 + 5 = 7. But what about the third? It seems that R added 3 + 4 = 7. But why?\nR noticed that it is missing an element to be added to the third element of the vector numbers1. So, it did what is called recycling. It “rewound” the vector numbers2 to the beginning and added the first element of numbers2 to the third element of numbers1. However, since after the rewinding and adding one element of vector numbers2 was left (because numbers1 did not have any more elements), R issued a warning. If the length of the first vector was a multiple of the length of the second vector, R would not have complained:\n\nnumbers1 &lt;- c(1, 2, 3, 4, 5, 6)\nnumbers2 &lt;- c(7, 8)\nnumbers1 + numbers2\n\n[1]  8 10 10 12 12 14\n\n\nSee? No warning. R was recycling the second vector over and over again. Recycling is a dangerous business: if you are not careful, you can get results which you have not expected.\n\n\n\n\n\n\nRecycling advice\n\n\n\nHere is our advice to you: either use a vector and a single element vector, or two vectors of the same length. And in the cases where, for some reason, you need to recycle, make sure that you know what you are doing. For example, check the length of both vectors.\n\n\nWith vectors that have only a couple of numbers it is quite easy to see what is happening, but what if you have thousands of variables? In other words, how to check the lenght of a vector? You can use the length():\n\nlength(numbers1)\n\n[1] 6\n\nlength(numbers2)\n\n[1] 2\n\n\n\n\n\n\n\n\n\nExercise 1.7 (Vectorisation)  \n\nCreate a vector with several numbers and try to add, subtract, multiply and divide it by a single number. What happens?\nSay, you have three values which are the diameters of three circles: 1, 5 and 13. You would like to have a vector containing the areas of these circles. What is the simplest way of doing that?\nHow do you check the length of this vector?\nOne vector, lengths, contains the lengths of the sides of three rectangles, and the other, widths, contains their widths. Create a vector containing the areas of these rectangles.\n\n\n\n\n\n\n\n1.5.5 The special value NA\nOne more thing: there are a couple of special values in R that you should know about. One of the most prominent, useful and frequently encountered is the NA value, which stands for “Not Available”. You will see it frequently when you work with data.\nIt is possible to apply mathematical operations to NA values, but the result is inadvertently NA:\n\nNA + 1\n\n[1] NA\n\nnumbers &lt;- c(1, 2, NA, 4)\nnumbers * 3\n\n[1]  3  6 NA 12\n\n\nThis also goes for some functions, which, quite often, have a special parameter to omit the NA values. For example, the mean() function calculates the mean of a vector:\n\nnumbers &lt;- c(1, 2, NA, 4)\nmean(numbers)\n\n[1] NA\n\nmean(numbers, na.rm=TRUE)\n\n[1] 2.333333\n\n\n\n\n\n\n\n\nUseful functions\n\n\n\nThere is a whole bunch of functions that you can use to work with vectors, and here are some of them – with mostly self-explanatory names: sum(), min(), max(), range(), sd(), var(), median(), quantile(). Look them up in the help system by typing, for example, ?sum in the console.\n\n\nThe NA value very frequently pop up when you try to convert a character vector holding what looks like numbers into a numeric vector. We will see many such examples in the days to come; the conversion is often done using the as.numeric() function. For example, it is quite common that values typed in a spreadsheet contain comments or values which look like this &gt; 50 (measurement out of range).\n\nimported_data &lt;- c(\"10\", \"20\", \"30\", \"&gt; 50\", \"40\", \"N.A.\", \"60 (unsure)\")\n# this will generate a warning\nimported_data &lt;- as.numeric(imported_data)\n\nWarning: NAs introduced by coercion\n\nimported_data\n\n[1] 10 20 30 NA 40 NA NA\n\n\nAs you can see, R conveniently warns you that some elements of the vector were changed to NA. Look out for that warning!\n\n\n\n\n\n\nSpecial values\n\n\n\nThere are a few other special values in R that behave similarly to NA. Inf stands for infinity, you will get it when you divide a positive number by zero: 1/0. -Inf is the negative infinity (when you divide a negative number by 0), and NaN stands for “Not a Number” – this is what you get when you try to subtracting Inf - Inf or dividing 0/0. They have also other uses – for example, if a function wants to know how many rows of output you would like to see, and your answer is “all of them”, you can use Inf as the number of rows.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "day1-intro-to-r.html#putting-it-all-together",
    "href": "day1-intro-to-r.html#putting-it-all-together",
    "title": "1  Day 1: Introduction to R",
    "section": "1.6 Putting it all together",
    "text": "1.6 Putting it all together\n\n1.6.1 Water lillies on a lake\nThere is an old puzzle that goes: “On a lake, there is a water lily. Each day the lily doubles in size. After 30 days, the lily covers the entire lake. On which day was the lily covering half of the lake?”.\nIn the following section we will model the behavior of the lily using R. Let us start with some assumptions. First: we designate the first day as Day 1. Second: every day, the lily doubles the area it covers. Third: on the first day, the lily covers 1% of the lake.\n\n\n\n\n\n\n\nExercise 1.8 (Modelling water lilies) Take a piece of paper and a pen. Your task is to come up with a formula to describe the area of the lily on the \\(n\\)-th day. Write down the formula.\nHint: if you are stuck, try to calculate the area of the lily on the first few days.\n\n\n\n\nThere is an important point that we wish to demonstrate here. Quite often it pays off to close your laptop and think for a moment what it is it that you want to do, rather than start coding right away. Pen and paper are helpful (we will be making this point again when it comes to visualizations). If you do not have a clear idea of what you want to do, you can get stuck thinking about what you already know how to do.\nThe formula for calculating the area of the lily on the \\(n\\)-th day is \\(0.01 \\times 2^{n-1}\\). You can come up with that result quite easily if you consider the first few days. On day 1, the area is \\(1\\% = 0.01\\). On day 2, is twice that, that is, \\(0.01 \\times 2 = 0.01 \\times 2^1 = 0.02\\). On day 3, it is twice the area from the previous day: \\(0.02 \\times 2 = 0.04 = 0.01 \\times 2\n\\times 2 = 0.01 \\times 2^2\\). And again, on day 4, it is \\(0.01 \\times 2^3\\). And so on2. We can show it in a table:\n\n\n\n\n\n\n\n\n\nDay\nArea\nCalculation\nFormula\n\n\n\n\n1\n0.01\n\\(0.01\\)\n\\(0.01 \\times 2^0\\)\n\n\n2\n0.02\n\\(0.01 \\times 2\\)\n\\(0.01 \\times 2^1\\)\n\n\n3\n0.04\n\\(0.01 \\times 2 \\times 2\\)\n\\(0.01 \\times 2^2\\)\n\n\n4\n0.08\n\\(0.01 \\times 2 \\times 2 \\times 2\\)\n\\(0.01 \\times 2^3\\)\n\n\n5\n0.16\n\\(0.01 \\times 2 \\times 2 \\times 2 \\times 2\\)\n\\(0.01 \\times 2^4\\)\n\n\n\nOnce we have the formula, it is very easy to calculate the area covered by water lillies on the first 10 days. We will use vectorization to do this:\n\ndays &lt;- 1:10\narea &lt;- 0.01 * 2^(days - 1)\narea\n\n [1] 0.01 0.02 0.04 0.08 0.16 0.32 0.64 1.28 2.56 5.12\n\n\nThis calls out for a plot. We will talk about visualizations more extensively on Day 5, but for now, we will use a very basic and simple function to plot the area of the lily on the first 30 days. The function is called plot() and can be used to plot a graph of two vectors. The first vector is the days, the second vector is the area.\n\nplot(days, area, type=\"b\")\n\n\n\n\n\n\n\n\nO-K, days and area are clear, but what is this type=\"b\"? This is a so-called named argument3. The plot() function has many arguments, and if you want to use only some of them, you can use their names with an equal sign. You will see that a lot in the days to come. This particular argument, type, tells R what kind of plot to draw. The \"b\" stands for “both” and tells R to draw both points and lines. If you want only points, you can use \"p\" (or simple leave the argument out), if you want only lines, you can use \"l\".\nNote another thing on this plot: after day 7, the area is greater than 1. But 1 means 100%, so after day 7, the lily covers more than the entire lake. Obviously, this is not possible – and it shows a limitation of our model. We can show it by adding a horizontal line to the plot:\n\nplot(days, area, type=\"b\")\nabline(h=1, col=\"red\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 1.9 (Plotting water lilies)  \n\nCreate the same plot using the plot() function, but add, as a parameter, col=\"blue\". What happens?\nUse the argument xlab to label the x-axis with “Day”. Use the argument ylab to label the y-axis with “Area”. Use the argument main to give the plot a title.\nUse the argument ylim=c(0, 1) to change the range of the y-axis. How would you change the limit of the x axis?\nWhat is the formula for the area of the lily assuming that each day, the lily covers 1.5 times the area of the previous day?\nCreate a new area vector (call it area_slow) which will be calculated with the new formula.\nAdd the new vector to the plot using the function lines(). What does the lines() function do? (Hint: type ?lines in the console).\n\n\n\n\n\n\n\n1.6.2 Functions in R\nR is a so-called functional language. This is different from many other languages (including Python). It has some interesting implications which we will partially explore over the next few days. For now, however, we will be content with one important statement: in R, most of the stuff you do, you do using functions. A function takes zero or more arguments and returns exactly one argument.\nDuring this course, we will not really discuss or require creating your own functions. However, we would nonetheless like to show you how it is done. There are two reasons for that. Firstly, it is really, really easy. Secondly, it will help you understand how functions work in R, and that will help you understand how to use functions that others have created.\nIn the water lilies example we have used a formula to calculate the area of the lily on the \\(n\\)-th day. The formula includes two parameters: the initial fraction of the area covered by the lily on day 1, and the factor by which the area is increased each day. We can create a function that will take three parameters: the day (or days), the initial fraction and the factor, and return the area of the lily on that day. Here is how you can do it:\n\narea_lily &lt;- function(day, fct) {\n  ret &lt;- 0.1 * fct^(day - 1)\n  return(ret)\n}\n\nAs you can see, the function is created using the function keyword. In parentheses (( and )), you specify the arguments that the function takes, separated by commas. Then comes the body of the function, enclosed in the curly braces ({ and }). On the last line of the function code, the return() function is used to return the value of the area_lily function.\nOne interesting and important fact about the code above is that you use the assignment operator &lt;- to assign the function to a variable. In other words, area_lily is, in fact, a variable! A variable which holds not a value or character string, but computer code that can be used to do stuff.\nOnce you have run the code above, you can use it to calculate the area of the lily on the first 10 days like this:\n\narea &lt;- area_lily(1:10, 2)\nprint(area)\n\n [1]  0.1  0.2  0.4  0.8  1.6  3.2  6.4 12.8 25.6 51.2\n\n\n\n\n\n\n\n\n\nExercise 1.10 (Creating your own function) Modify the area_lily function so that it takes three arguments: the day, the initial fraction and the factor. Use the new function to calculate the area of the lily on the first 10 days with the initial fraction of 0.001 and the factor of 1.5. What is the area on the 10th day?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "day1-intro-to-r.html#coding-practices",
    "href": "day1-intro-to-r.html#coding-practices",
    "title": "1  Day 1: Introduction to R",
    "section": "1.7 Coding practices",
    "text": "1.7 Coding practices\n\n1.7.1 Computer programs as means for communication\nIt is now time to conclude today’s lesson with a bit of philosophy. When you write an R script, the first goal you have in mind is to analyse your data – in other words, by means of what you write you are trying the computer to do something for you. That is correct and fine, but there is an important aspect of programming that is often overlooked.\nWhen you write a program, you are writing it not only for the computer, but also for other people. These other people may include your colleagues, readers of your scientific articles, your students, and, last but not least, a future version of yourself. All these people need more then just a piece of code that works. You will quickly find it out yourself when you open a script or a project that you have not been working on for a few months – trust me on this, you will not know what it does, how it does and sometimes even whether you have written it or copied from somewhere.\nYou might be thinking that you are never willing to show your code to another person. You are wrong, and not only because it is useful to you for another person to review your code. Firstly, you will want to share your code because as a scientist you will want to share your results, and results are nothing if the methods to obtain them are unknown. And secondly, you will need to share your code because you will be asked to do so by your colleagues (yes, I was as surprised as you will be when I was asked to share my code for the first time). And thirdly, your code is part of your methods and you will have to share it when you publish your results4.\nFor communication with another human being to be efficient, you need to make it as clear as possible. There are several ways how to make your code more readable and understandable. Here are some of them.\nComments. Comments are lines in your code that are not executed. In R, they start with a # sign. Comments help to explain what exactly are you trying to achieve with your code. The old saying goes: “Code tells you how, comments tell you why”. You can hardly overdo with comments, but you can easily underdo.\nNaming. The names of your variables, functions and files should be meaningful. If you have a variable that stores the number of days, call it days, not x. If you have a function that calculates the area of a circle, call it calculate_circle_area(), not f(). If you have a comma separated values (CSV) file that contains the CRP values, call it crp_values.csv, not data.txt.\nFormatting. Your code should be formatted in a consistent way. For example, you should always put a space around your operators, like x &lt;- 2 (and not x&lt;-2), you should always put a space after a comma, like c(1, 2) and not c(1,2) (and also not c( 1 , 2 )). Lines should not be too long – 80 characters at most is a good rule of thumb. If a line is too long, you can split it into several lines – R will not mind. See here for a more detailed guide on how to format your code.\n\n\n1.7.2 Example\nThe following fragment of code shows how you should not format your code:\n\na&lt;- 4\nb &lt;-c(1,10, \n20, 21, 5)\nr&lt;-sqrt(sum((b-mean(b))^2)/\n               a)\n\nThe code is correct, but it is hard to read. What does it do, quickly? If you carefuly examine it, you will see that it calculates the standard deviation of the vector b, following the formula\n\\[SD = \\sqrt{\\frac{\\sum_{i=1}^{n} (x_i - \\bar{x})^2}{n-1}}\\]\nwhere \\(n\\) is the length of the vector b, \\(x_i\\) is the \\(i\\)-th element of the vector b and \\(\\bar{x}\\) is the mean of the vector b. However, there are several issues.\nFirstly, there are no comments in the code which would give a hint of what it does. Secondly, \\(n - 1\\) (the variable a) is hard encoded - if you modify the vector b by adding one number, the code will execute, but the result will be incorrect.\nThirdly, line 4 combines several operations making it very hard to read. It should be split for clarity. The following code is much more readable:\n\n# ---------------------------------------------------------\n# Calculating the standard deviation of a sample\n# ---------------------------------------------------------\n\n# example values for five samples\nsamples &lt;- c(1, 10, 20, 21, 5)\nsamples_n &lt;- length(samples)\n\n# calculate standard deviation of samples manually\nsamples_mean &lt;- mean(samples)\nsamples_devs &lt;- samples - samples_mean\n\n# samples variance\nsamples_var &lt;- sum(samples_devs^2) / \n                (samples_n - 1)\n\nsamples_sd &lt;- sqrt(samples_var)\n\nThis makes it absolutely clear what you are trying to do, and, in addition, calculates the mean, the deviations, sample length and sample variance – all of which might come in handy later on. Also note of the use of # ----… comments. Programmers often use these to highlight the beginning of a new section of code. This is not necessary, but adds to readability. Lines 14 and 15 show how you can split a line of code in a way that is both readable and clear.\nOf course, the example is a bit silly – R has a lot of built-in statistical functions, and standard deviation naturally is one of them. You can calculate the standard deviation of a vector b using the sd() function:\n\nsamples_sd &lt;- sd(samples)\n\nNonetheless, the principle stands.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "day1-intro-to-r.html#review",
    "href": "day1-intro-to-r.html#review",
    "title": "1  Day 1: Introduction to R",
    "section": "1.8 Review",
    "text": "1.8 Review\nThings that you learned today:\n\nWorking with R and RStudio\n\nCreating and running scripts\nUsing the console\nUsing the “Environment” panel of RStudio\nUsing comments with the # sign\nUsing tab completion\n\nVariables\n\nAssigning values to variables\nUsing variables in calculations\nUsing character variables\npasting together character variables with paste() and paste0()\n\nVectors\n\nCreating vectors with c() and :\nAccessing elements of a vector with [ ]\nNamed vectors\nAssigning values to selected elements\nVectorization\nRecycling\n\nUseful functions\n\nsqrt(), log(), log2(), log10(), sin(), cos(), tan()\nsum(), mean(), min(), max(), range(), sd(), var(), median(), quantile()\n\nOther\n\nThe special values NA, Inf, -Inf, NaN\nLogical values TRUE and FALSE\nFunctions in R\nPlotting with plot()\nAdding parameters to functions\nCoding practices\n\n\nXXX",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "day1-intro-to-r.html#footnotes",
    "href": "day1-intro-to-r.html#footnotes",
    "title": "1  Day 1: Introduction to R",
    "section": "",
    "text": "There are exceptions to this rule, but they are relatively rare and we will not discuss them here.↩︎\nIf started counting from 0 – that is, if we designated the first day as Day 0 – the formula would be \\(0.01 \\times 2^n\\).↩︎\nFull disclosure: all arguments can be named in R. However, some of the arguments have a default value, so we do not have to specify them unless we need them. The type argument is one of them. Others must always be specified. We will talk about this in more detail later.↩︎\nTop journals already require that you share your code when you publish your results. This will become more and more common in the future.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Five days of R\nI have been teaching R to biologists and medical students for many years now. At the Core Unit for Bioinformatics at the Berlin Institute of Health, Charité - Universitätsmedizin Berlin, we have developed a five-day, 5 hour per day crash course running for the last three years. This book is a companion to that course.\nThis is also the reason for how the materials in the book are arranged. Rather then discussing everything about vectors first, then everything about matrices etc., we start with easy things, and return to them later to build on them. I call this “helical learning”1 – we spiral around the same topics, but each time going a bit deeper, and each time you will understand a bit more. This is also why some topics are spread between the days – by trial and error, we have found the amount of material that can be covered in a day of learning.\nThere are two goals of this book. The first one is that after five days of learning R, you will be able to load, inspect, manipulate and save data files (such as Excel tables or CSV files), make some basic plots and perform simple statistical tests. The second goal is that you are in a good starting position to continue learning R on your own.\nIn other words, this course should give you a jump start, allow to overcome this first hurdle of learning R.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#prerequisites",
    "href": "intro.html#prerequisites",
    "title": "Introduction",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nInstalling R and RStudio\nBefore you dive in to the course, we would like to ask you to install both R and RStudio. The installation depends on your operating system, so please refer to specific instructions which can be found at the following links:\nXXX\n\n\nInstalling R packages\nDuring the course we will use several R packages that you need to install on your computer. On Day 2, we will discuss installing and loading packages, and we will make a note to install the required packages when they are needed. However, you can also install them right now, after you have installed R and RStudio. This can be more effective – after all, installing might take some time.\nHere is the list of packages that you will have to install:\n\ntidyverse\nggplot2\ncolorDF\npander\nreadxl\nwritexl\ntinytex (only if you want to produce PDF output from Rmarkdown)\n\nYou can install them by running the following code in your RStudio:\n\ninstall.packages(c(\"tidyverse\", \"ggplot2\", \"colorDF\",\n                  \"pander\", \"readxl\", \"writexl\",\n                  \"tinytex\"))\n\n\n\nInstalling Quarto\nOn Day 5, we will be discussing Rmarkdown. Your basic RStudio setup will allow you to create Rmarkdown documents, but if you wish, you can also use Quarto – which is a sort of “Rmarkdown on steroids”, much nicer looking and efficient. However, for this you need to install the Quarto program. See the Quarto website (https://quarto.org/docs/get-started/) for details.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#the-structure-of-this-book",
    "href": "intro.html#the-structure-of-this-book",
    "title": "Introduction",
    "section": "The structure of this book",
    "text": "The structure of this book\nThis book is divided into five chapters, each corresponding to one day of the course. At the beginning of each chapter, you will find a short list of topics for the given day.\nIn each chapter there are several exercises. However, that does not mean that you should only do the exercises. In fact, you should try out every piece of code that is in the book. Copy it (there is a button next to each code block that will do it for you), paste it into your RStudio and run it. Then try to modify it and see what happens.\nExercises in this book are important. They are not only there to check if you understood the material, but they can also introduce new concepts or ideas. This is because this book is not only about learning R, but also learning how to learn about R. So, for example, sometimes we will want you to figure stuff on your own rather than give you a ready-made answer.\nEach chapter is ended by a “Review” section, which contains a list of things that you have learned that day. It is really important that you go through that list and make sure that you understand everything on it. Some of the new things appeared in the exercises, so if you skipped them, you might want to go back and do them.\nIf you do all that, I personally guarantee you that by the end of this course you will be able to use R in your work.\n\n\n\n\n\n\nRemember!\n\n\n\n\nRun all code chunks in your RStudio.\nDo all exercises.\nGo through the “Review” section at the end of each chapter.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#general-advice",
    "href": "intro.html#general-advice",
    "title": "Introduction",
    "section": "General advice",
    "text": "General advice\nThe course is a real crash course. There is a lot of material coming at you in a very short time. You will feel overloaded and overwhelmed – this is normal. Don’t worry! It will soon get better, and in a few days you will be able to do fairly advanced things with R.\nThe key is to keep playing with your R; trying out new things, breaking it. Please go through all exercises in that book, even if they seem simple at the first glance (some of them are tricky, others are used to smuggle in new concepts and useful tidbits of information).\nWhenever you feel you don’t understand something, stop and try to figure it out. Use internet search very liberally. Many answers can be found on sites such as StackOverflow, R-bloggers, or in the R documentation. Try out the code you will find in these sources – just copy-paste it into your RStudio and adapt it to your needs. Feel free to use Large Language Models (such as GPT) – they are very good at explaining code, especially when you are learning basic concepts.\nHowever, if you want to learn R, simply doing this course will not be enough. You need to start using it in a real world setting. Unfortunately – the better you already are at Excel, Word and other such tools, the harder it will be switching to R: tasks that are a breeze in Excel will at first require you to spend substantially more time in R. However, trust me: it pays off in the long run. Therefore, for best results, force yourself to use R even if at first it is less efficient then other tools.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Introduction",
    "section": "",
    "text": "I got this idea from the professor Barbara Płytycz from the Jagiellonian University, who taught me my first “helix” of the immune system.↩︎",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "day3-reading-your-data.html",
    "href": "day3-reading-your-data.html",
    "title": "3  Day 3: Reading and Writing Files",
    "section": "",
    "text": "3.1 Aims for today\nToday is a special day. If there is one thing that I would like you to learn from this course, it is how to read and write the data.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "day3-reading-your-data.html#aims-for-today",
    "href": "day3-reading-your-data.html#aims-for-today",
    "title": "3  Day 3: Reading and Writing Files",
    "section": "",
    "text": "Reading data\nCleaning data\nRegular expressions\nSearching, sorting and selecting - a start",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "day3-reading-your-data.html#reading-data",
    "href": "day3-reading-your-data.html#reading-data",
    "title": "3  Day 3: Reading and Writing Files",
    "section": "3.2 Reading data",
    "text": "3.2 Reading data\n\n3.2.1 Data types\nIn your work you will encounter many different types of data. Most frequently, you will work with tabular data, either as Excel files or as comma or tab separated values (CSV and TSV files, respectively). I am sure you have worked with such files before.\nTo read these files, we will use two packages: readr and readxl. The former, readr, is part of the tidyverse package, so when you load the Tidyverse using library(tidyverse), readr is loaded as well. The latter, readxl, is a separate package that you need to install and load separately.\nThere are also “base R” functions read.table, read.csv, read.tsv (there is no function for reading XLS[X] files in base R). These are always available when you start R, but don’t use them. The tidyverse functions are not only faster, but also much better behaving and, which is most important, they are safer – it is less likely to mess up your data with them.\nTidyverse functions return tibbles, which, as you remember from yesterday, are a special flavor of data frames. Just to refresh your memory, here are key facts about tibbles:\n\nin most of the cases, they behave exactly like data frames\nwhen you print them, they are nicer\ntibbles have no row names\nwhen you select columns using [ , sel ], you always get a tibble, even if you selected only one column\n\n\n\n\n\n\n\n\n\n\nData type\nFunction\nPackage\nNotes\n\n\n\n\nColumns separated by spaces\nread_table()\nreadr/tidyverse\none or more spaces separate each column\n\n\nTSV / TAB separated values\nread_tsv()\nreadr/tidyverse\nDelimiter is tab (\\t).\n\n\nCSV / comma separated\nread_csv()\nreadr/tidyverse\nComma separated values\n\n\nAny delimiter\nread_delim()\nreadr/tidyverse\nCustomizable\n\n\nXLS (old Excel)\nread_xls() read_excel()\nreadxl\nAvoid using XLS files. From the readxl package.\n\n\nXLSX (new Excel)\nread_xlsx() read_excel()\nreadxl\nFrom the readxl package. You need to provide the sheet number you wish to read. Note: returns a tibble, not a data frame!\n\n\n\nAs you can see, the functions we recommend to use can be used by loading the packages tidyverse and readxl. If you haven’t done that yet, please install these packages now:\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"readxl\")\n\nHowever, before we start using these functions, we need to dive into a very important problem: where are your files?\n\n\n\n\n\n\nRemember!\n\n\n\n\nFor reading text files (csv, tsv etc.), use the readr package. This package is loaded automatically when you load the tidyverse package: library(tidyverse). Then, use the functions read_csv, read_tsv etc.\nFor reading Excel files, use the readxl package: library(readxl). Then, use the function read_excel.\n\n\n\n\n\n3.2.2 Where is my file? Relative and absolute paths\nWe are coming now to a crucial problem and a source of endless frustration for beginning R programmers: how to tell R where your file is. Fortunately, there are many ways to deal with that, both with R and RStudio. Still, this is a key problem and we would like you to spend some time on the following chapter.\nIn order to access a file, a program (any program) needs what is known a path. Path is a character string that tells the program how to get to the file and looks, for example, like this on a Windows computer: C:/Users/johndoe/Documents/RProjects/MyFirstRProject/data.csv, and like this on a Mac: /Users/johndoe/Documents/RProjects/MyFirstRProject/data.csv.\n\n\n\n\n\n\nPath separators on different systems\n\n\n\nMost computer systems separate the directories and files in a path using a slash (/). However, Windows uses a backslash (\\). This is a source of endless frustration for R users, because in R character vectors, the slash has a special meaning. To use backslashes, you need to “escape” them by putting another backslash in front of each backslash. So instead of C:\\Users\\johndoe\\Documents, you need to write C:\\\\Users\\\\johndoe\\\\Documents. Alternatively, you can use the forward slash even on a Windows system, so type C:/Users/johndoe/Documents. We recommend the latter approach.\nThis is also why simply copying a path from the Windows Explorer to your R script will not work in R – because the copied text contains single backslashes.\n\n\nIf R cannot find your file, it will return an error message. At first, you will be seeing this error a lot:\n\nlibrary(tidyverse)\nmydata &lt;- read_csv(\"data.csv\")\n\nError: 'data.csv' does not exist in current working directory ('/home/january/Private/Ksiazki/rcrashcourse-book/r-crash-course').\n\n\nBefore we proceed, you need to understand one important thing. When you start your RStudio and R session, the R session runs in a specific directory. This is called the working directory. You can check what is using the getwd() function1:\n\ngetwd()\n\n[1] \"C:/Users/johndoe/Documents/RProjects/MyFirstRProject\"\n\n\nOf course, the result will be different on your computer. By the way, the above is called an absolute path. That means that it works no matter where you are in your system, because a program can always find the file or directory using this path.\nThe easiest way to read the data is this: copy your data files to the directory returned by getwd().\n\n\n\n\n\n\n\nExercise 3.1 (Reading your first file)  \n\nCheck your working directory using getwd()\nLoad the tidyverse package using library(tidyverse)\nGo to the URL https://github.com/bihealth/RCrashcourse-book/Datasets\nClick on “iris.csv”\nClick on the “Download raw file” button on the right side of the screen\nSave the file in the directory returned by getwd()\nRead the file using read_csv(\"iris.csv\")\n\n\n\n\n\nThe following code should work without an error:\n\nlibrary(tidyverse)\niris_data &lt;- read_csv(\"iris.csv\")\n\nNow the contents of the file are stored in the iris_data object. There are many ways to have a look at it:\n\ntype iris_data or print(iris_data) in the console\ntype View(iris_data) in the console\nclick on the little spreadsheet icon next to the iris_data object in the Environment tab in RStudio (upper right panel)\n\nPlease make sure that the above works for you. If it does not, read the instructions again. In RStudio, there is a “Files” tab in the lower right panel. You should see your working directory as well as the “iris.csv” file there.\n\n\n3.2.3 Reading with relative paths\nOK, so far, so good. That was easy. Now comes a slightly harder part.\nSaving your data files in the working directory works well if you have one or two. However, the more files you read and write, the more cluttered your project directory becomes. You will soon find yourself in a situation where you have no idea which file is which.\nIt is generally a good idea to keep your data files in a separate directory, or even multiple directories.\n\n\n\n\n\n\n\nExercise 3.2 (Reading your first file from a data directory)  \n\nIn the working directory, create a new directory called “Data”\nMove the “iris.csv” file to the “Data” directory\nRead the file using read_csv(\"Data/iris.csv\")\n\n\n\n\n\nThe path “Data/iris.csv” is called a relative path, because it is relative to the working directory and will not work from another location. So why should we use relative paths? Wouldn’t it be easier to use absolute paths all the time, for example read_csv(\"C:/Users/johndoe/Documents/RProjects/MyFirstRProject/Data/iris.csv\")?\nActually, no. The problem is that if you move your R project to another location, of if you share it with someone else, the absolute path will no longer work. In other words, the absolute path is not portable.\n\n\n\n\n\n\nRemember!\n\n\n\nDo not use absolute paths in your code. Always use relative paths.\n\n\n\n\n3.2.4 More on relative paths\nSome times the data files are not in your R project directory. For example, you are writing your PhD thesis. You have created a directory called “PhD”, which contains directories “manuscript”, “data”, “images”, “R_project” and so on. You use R to do a part of the calculations, but you want to keep the data files in the “data” directory. How to read them?\nWhen you type getwd(), you will get the path to the “R_project” directory, something like C:/Users/johndoe/Documents/PhD/R_project. The date files are in the directory C:/Users/johndoe/Documents/PhD/data. To get the relative path from the R project directory to the data directory, think about how you would navigate from one directory to another in the Windows Explorer or Finder. You need to go up one level, to get into “PhD”, and then down again to “data”.\nGetting “up one level” in a path is done by using ... So the relative path to the file “iris.csv” in your “data” directory is ../data/iris.csv.\n\n\n\n\n\n\n\nExercise 3.3 (Reading a file from a data directory using relative paths)  \n\nIn the directory that contains the working directory create a directory called “Data”. That is, if your working directory is C:/Users/johndoe/Documents/PhD/R_project, create the directory C:/Users/johndoe/Documents/PhD/Data\nMove the “iris.csv” file to the new “Data” directory\nRead the file using read_csv(\"../Data/iris.csv\")\n\n\n\n\n\nBut what about the case when your data directory is at a completely different location? For example, on a different drive, or maybe on your desktop?\nFirst, I don’t recommend keeping your data files separately from the R project directory. In general, try to put everything in one place, as part of one structure. This structure can be complex, but it should be coherent. If necessary, copy the data files into your R project directory.\nHowever, sometimes it simply isn’t possible. Maybe the files are huge and you need to read them from a special drive. In this case, there are three options.\nUsing absolute paths. Yes, I told you not to use absolute paths, but sometimes you have no choice.\nCreate shortcuts. In all systems it is possible to create shortcuts to your data directories (on Unix-like systems like MacOS they are called “symbolic links”). You can put these shortcuts in your R project directory – R will treat them as normal directories.\nCreate a complex relative path. Depending on how far “away” your data directory is, you can create a complex relative path. For example, if your R project directory is C:/Users/johndoe/Documents/PhD/R_project and your data directory is D:/Data, you can use the path ../../../../Data/iris.csv. Unfortunately, despite being a relative path, this is not very portable (and it is easy to lose count on the ..’s).\n\n\n3.2.5 Using RStudio to import files\nRStudio has a very nice feature that allows you to import files using a point-and-click interface. When you click on a data file in the “Files” tab (lower right panel), you will see two options: “View File” and “Import Dataset”. Choosing the latter opens a dialog window which shows a preview of the file and allows you to construct your read_csv, read_tsv or another command using a point-and-click interface. You also see a preview of the expression that will be executed.\nThis feature is particularly useful when you are not sure about the format of the data to import, e.g. what type of delimiter is used, how many lines should be skipped etc.\nThen you can click on “Import” to actually run the command, however I would recommend another approach. Clicking on “Import” runs the command directly in the console, bypassing your script – and you should always enter the code in your script before executing it.\nRather than clicking on “Import”, click on the little Copy icon next to the “Code preview” field, and then cancel the dialog. Paste the copied code into your script, and then run it.\nThere is one more thing to modify. The code generated by RStudio often uses absolute paths. Try to modify it to use relative paths to ensure portability of your script.\n\n\n\n\n\n\n\nExercise 3.4 (Reading data)  \n\nGo to the URL https://github.com/bihealth/RCrashcourse-book/Datasets\nDownload the following files:\n\nTB_ORD_Gambia_Sutherland_biochemicals.csv\niris.tsv\nmeta_data_botched.xlsx\n\nAlternatively, you can download the whole repository as a ZIP file and unpack it.\nSave the files in the “Data” directory in your working directory – or another location of your choice.\nRead the files using the appriopriate functions. Consult the table above for the correct function names, or use the RStudio data import feature. Make sure that you are using relative paths.\n\n\n\n\n\n\n\n3.2.6 Reading Excel files\nReading files sometimes requires diligence. This is especially true for Excel files – they can contain multiple sheets, tables often do not start on the first row etc.\nThe package readxl (which you hopefully successfully used to read the XLSX file in the previous exercise) contains several example files. They have been installed on your system when you installed the package. Manually finding these example files is annoying, and that is why the readxl package provides a convenience function, readxl_example(), that returns the absolute path to the file (yes, I know what I said about absolute paths; this is an exception).\n\nlibrary(readxl)\nfn &lt;- readxl_example(\"deaths.xls\")\nprint(fn)\n\n[1] \"/home/january/R/x86_64-pc-linux-gnu-library/4.4/readxl/extdata/deaths.xls\"\n\ndeaths &lt;- read_excel(fn)\n\nNew names:\n• `` -&gt; `...2`\n• `` -&gt; `...3`\n• `` -&gt; `...4`\n• `` -&gt; `...5`\n• `` -&gt; `...6`\n\n\nIf you view this file (or if you use the RStudio data import feature), you will notice that the actual data in this file starts on line 5; the first 4 lines contain the text “Lots of people simply cannot resist writing some notes at the top of their spreadsheets or merging cells”. To skip these lines, we need to use an argument to the read_excel function. If you look up the help file for the function, you will find the following line:\nskip    Minimum number of rows to skip before reading anything,\n        be it column names or data. Leading empty rows are \n        automatically skipped, so this is a lower bound. Ignored\n        if range is given.\nTherefore, we can modify the code above to skip the first four lines:\n\ndeaths &lt;- read_excel(fn, skip=4)\n\n\n\n\n\n\n\n\nExercise 3.5 (Reading data with options) If you take a closer look at the file deaths.xls, you will notice that there is some extra text at the bottom of the file as well. How can you omit that part when reading? Hint: there are two ways to do that. If in doubt, look up the “examples” section of the readxl helpfile.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "day3-reading-your-data.html#footnotes",
    "href": "day3-reading-your-data.html#footnotes",
    "title": "3  Day 3: Reading and Writing Files",
    "section": "",
    "text": "You can change it using the setwd() function, but avoid doing that. This path leads to madness, trust me on that.↩︎\nIn this case, it was me.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "day3-reading-your-data.html#review",
    "href": "day3-reading-your-data.html#review",
    "title": "3  Day 3: Reading and Writing Files",
    "section": "3.4 Review",
    "text": "3.4 Review\nThings that you learned today:\n\nReading and writing\n\nread_csv, read_tsv, read_delim, read_xls, read_xlsx\nreading a file from working directory\nreading a file from a different directory using relative paths\n\nPaths\n\nGet the current working directory with getwd()\nrelative and absolute paths\n\nDiagnosing datasets\n\nstr, class, typeof\nsummary_colorDF\n\nOther\n\naccessing functions in a package without loading it (colorDF::summary_colorDF)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "day3-reading-your-data.html#reading-diagnosing-and-cleaning-data",
    "href": "day3-reading-your-data.html#reading-diagnosing-and-cleaning-data",
    "title": "3  Day 3: Reading and Writing Files",
    "section": "3.3 Reading, diagnosing and cleaning data",
    "text": "3.3 Reading, diagnosing and cleaning data",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "day3-reading-your-data.html#diagnosing-and-cleaning-data",
    "href": "day3-reading-your-data.html#diagnosing-and-cleaning-data",
    "title": "3  Day 3: Reading and Writing Files",
    "section": "3.3 Diagnosing and cleaning data",
    "text": "3.3 Diagnosing and cleaning data\n\n3.3.1 Diagnosing datasets\nCongratulations! You are now proficient in reading data into R. Believe me or not, this alone is an important step forward – many who try their hand at R get stuck at this point.\nHowever, reading data is only the first step. In most of the cases, the data requires some treatment: cleaning, transformation, filtering etc. In many projects that I have worked on as a bioinformatician, data import, diagnosis and cleaning took up the majority of time spent on the project. Unfortunately, this is necessary before any real fun with the data can start.\nLet us examine the file “iris.csv” that you have just read. The dataset comes from a famous paper by Ronald Fisher, who used it to demonstrate his newly developed method called linear discriminant analysis – an early machine learning algorithm, if you will. The dataset contains measurements of 150 flowers of three species of irises: Iris setosa, Iris versicolor and Iris virginica. The measurements are the sepal and petal length and width, four measurements in total. Each row consists of these four measurements, plus a column which contains the species name.\nI have doctored the file to mimick typical problems with imported data, especially in clinical trial settings. Humans who enter data make errors, this is normal and expected, all of us do. Before we analyse them, we need to correct them. Before we correct them, we need to find them.\nFirst, note that when you read the data using read_csv, the function conveniently shows what types of data were assigned to each column:\n\niris_data &lt;- read_csv(\"Datasets/iris.csv\")\n\nRows: 150 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): Sepal Length, Petal?Length, Species\ndbl (2): Sepal Width, Petal.Width\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThis should already ring some alarm bells. First, it looks like the columns are not consistently named: we have Sepal Length and Petal?Length, and also Petal.Width.\nSecondly, we would expect that the measurements are imported as numbers. However, both sepal and petal lengths are imported as characters. We can confirm this by using the class function:\n\nclass(iris_data[[\"Sepal Length\"]])\n\n[1] \"character\"\n\nclass(iris_data[[\"Sepal Width\"]])\n\n[1] \"numeric\"\n\nclass(iris_data[[\"Petal?Length\"]])\n\n[1] \"character\"\n\nclass(iris_data[[\"Petal.Width\"]])\n\n[1] \"numeric\"\n\n\n\n\n\n\n\n\nclass and typeof\n\n\n\nThe class function returns the class of an object, which is a higher-level classification of the object. An object can have multiple classes. The typeof function returns the internal type of the object, which is a lower level classification. For example, both tibbles and data frames have the type list, but their classes are different.\n\n\nNote that instead of using iris_data$Sepal Length (which will not work, because there is a space in the column name), we use the double bracket notation. An alternative would be to use quotes: iris_data$'Sepal Length'. This a reason why want to avoid spaces and special characters in column names (in a moment we will show you how to standardize column names). If you use tab-completion with RStudio, the quotes will be inserted automatically.\nAnother way how we can diagnose the dataset is to use the str function. This provides a more detailed summary for each column:\n\nstr(iris_data)\n\nspc_tbl_ [150 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ Sepal Length: chr [1:150] \"5.1\" \"4.9\" \"4.7\" \"4.6\" ...\n $ Sepal Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal?Length: chr [1:150] \"1.4\" \"1.4\" \"1.3\" \"1.5\" ...\n $ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : chr [1:150] \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   `Sepal Length` = col_character(),\n  ..   `Sepal Width` = col_double(),\n  ..   `Petal?Length` = col_character(),\n  ..   Petal.Width = col_double(),\n  ..   Species = col_character()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\n\n\n3.3.2 Using colorDF to diagnose datasets\nI have written a package called colorDF that creates yet another flavor of data frames, which is displayed in the console in color (if you haven’t installed it yet, do so now with install.packages(\"colorDF\"). However, we will only use one convenient function from this data set, summary_colorDF. Because summary_colorDF is too much to type, we will use a shortcut, scdf.\n\nscdf &lt;- colorDF::summary_colorDF\nscdf(iris_data)\n\n# Color data frame (class colorDF) 5 x 5:\n │Col         │Class│NAs  │unique│Summary                                   \n1│Sepal Length│&lt;chr&gt;│    0│    37│5: 10, 5.1: 9, 6.3: 9, 5.7: 8, 6.7: 8, 5.…\n2│Sepal Width │&lt;dbl&gt;│    0│    25│ 2.00 [ 2.80 &lt; 3.00&gt;  3.38] 36.00         \n3│Petal?Length│&lt;chr&gt;│    0│    44│1.4: 13, 1.5: 13, 4.5: 8, 1.3: 7, 1.6: 7,…\n4│Petal.Width │&lt;dbl&gt;│    0│    22│0.1 [0.3 &lt;1.3&gt; 1.8] 2.5                   \n5│Species     │&lt;chr&gt;│    0│     6│virginica: 46, setosa: 45, versicolor: 42…\n\n\nAbove we have created a copy of the summary_colorDF function in the variable scdf. This new variable behaves exactly like the original and you can use it just as you would use summary_colorDF. The colorDF:: prefix is there so that we don’t have to load the colorDF package. Instead we tell R to look for the function directly in the colorDF package.\nThis summary function shows more than just the str function. In addition to column types, for character and factor columns it shows the unique values, ordered by their frequency. For numerical values, it shows their non-parametric summary statistics (range, median, quartiles).\nHm, when you look at the output you might notice one more thing: for the last column, “Species”, summary_colorDF shows that there are six unique values. However, how can that be? We know that there are only three species in this dataset. We can check this using the unique function:\n\nunique(iris_data[[\"Species\"]])\n\n[1] \"setosa\"     \"Setosa\"     \"versicolor\" \"Versicolor\" \"virginica\" \n[6] \"Virginica\" \n\n\nThere it is. Looks like whoever typed the data2, sometimes used a lower-case species designation, and sometimes upper-case.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Five days of R",
    "section": "",
    "text": "Introduction",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#five-days-of-r",
    "href": "index.html#five-days-of-r",
    "title": "Five days of R",
    "section": "Five days of R",
    "text": "Five days of R\nI have been teaching R to biologists and medical students for many years now. At the Core Unit for Bioinformatics at the Berlin Institute of Health, Charité - Universitätsmedizin Berlin, we have developed a five-day, 5 hour per day crash course running for the last three years. This book is a companion to that course.\nThis is also the reason for how the materials in the book are arranged. Rather then discussing everything about vectors first, then everything about matrices etc., we start with easy things, and return to them later to build on them. I call this “helical learning”1 – we spiral around the same topics, but each time going a bit deeper, and each time you will understand a bit more. This is also why some topics are spread between the days – by trial and error, we have found the amount of material that can be covered in a day of learning.\nThere are two goals of this book. The first one is that after five days of learning R, you will be able to load, inspect, manipulate and save data files (such as Excel tables or CSV files), make some basic plots and perform simple statistical tests. The second goal is that you are in a good starting position to continue learning R on your own.\nIn other words, this course should give you a jump start, allow to overcome this first hurdle of learning R.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Five days of R",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nInstalling R and RStudio\nBefore you dive in to the course, we would like to ask you to install both R and RStudio. The installation depends on your operating system, so please refer to specific instructions which can be found at the following links:\nXXX\n\n\nInstalling R packages\nDuring the course we will use several R packages that you need to install on your computer. On Day 2, we will discuss installing and loading packages, and we will make a note to install the required packages when they are needed. However, you can also install them right now, after you have installed R and RStudio. This can be more effective – after all, installing might take some time.\nHere is the list of packages that you will have to install:\n\ntidyverse\nggplot2\ncolorDF\npander\nreadxl\nwritexl\ntinytex (only if you want to produce PDF output from Rmarkdown)\n\nYou can install them by running the following code in your RStudio:\n\ninstall.packages(c(\"tidyverse\", \"ggplot2\", \"colorDF\",\n                  \"pander\", \"readxl\", \"writexl\",\n                  \"tinytex\"))\n\n\n\nInstalling Quarto\nOn Day 5, we will be discussing Rmarkdown. Your basic RStudio setup will allow you to create Rmarkdown documents, but if you wish, you can also use Quarto – which is a sort of “Rmarkdown on steroids”, much nicer looking and efficient. However, for this you need to install the Quarto program. See the Quarto website (https://quarto.org/docs/get-started/) for details.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#the-structure-of-this-book",
    "href": "index.html#the-structure-of-this-book",
    "title": "Five days of R",
    "section": "The structure of this book",
    "text": "The structure of this book\nThis book is divided into five chapters, each corresponding to one day of the course. At the beginning of each chapter, you will find a short list of topics for the given day.\nIn each chapter there are several exercises. However, that does not mean that you should only do the exercises. In fact, you should try out every piece of code that is in the book. Copy it (there is a button next to each code block that will do it for you), paste it into your RStudio and run it. Then try to modify it and see what happens.\nExercises in this book are important. They are not only there to check if you understood the material, but they can also introduce new concepts or ideas. This is because this book is not only about learning R, but also learning how to learn about R. So, for example, sometimes we will want you to figure stuff on your own rather than give you a ready-made answer.\nEach chapter is ended by a “Review” section, which contains a list of things that you have learned that day. It is really important that you go through that list and make sure that you understand everything on it. Some of the new things appeared in the exercises, so if you skipped them, you might want to go back and do them.\nIf you do all that, I personally guarantee you that by the end of this course you will be able to use R in your work.\n\n\n\n\n\n\nRemember!\n\n\n\n\nRun all code chunks in your RStudio.\nDo all exercises.\nGo through the “Review” section at the end of each chapter.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#general-advice",
    "href": "index.html#general-advice",
    "title": "Five days of R",
    "section": "General advice",
    "text": "General advice\nThe course is a real crash course. There is a lot of material coming at you in a very short time. You will feel overloaded and overwhelmed – this is normal. Don’t worry! It will soon get better, and in a few days you will be able to do fairly advanced things with R.\nThe key is to keep playing with your R; trying out new things, breaking it. Please go through all exercises in that book, even if they seem simple at the first glance (some of them are tricky, others are used to smuggle in new concepts and useful tidbits of information).\nWhenever you feel you don’t understand something, stop and try to figure it out. Use internet search very liberally. Many answers can be found on sites such as StackOverflow, R-bloggers, or in the R documentation. Try out the code you will find in these sources – just copy-paste it into your RStudio and adapt it to your needs. Feel free to use Large Language Models (such as GPT) – they are very good at explaining code, especially when you are learning basic concepts.\nHowever, if you want to learn R, simply doing this course will not be enough. You need to start using it in a real world setting. Unfortunately – the better you already are at Excel, Word and other such tools, the harder it will be switching to R: tasks that are a breeze in Excel will at first require you to spend substantially more time in R. However, trust me: it pays off in the long run. Therefore, for best results, force yourself to use R even if at first it is less efficient then other tools.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Five days of R",
    "section": "",
    "text": "I got this idea from the professor Barbara Płytycz from the Jagiellonian University, who taught me my first “helix” of the immune system.↩︎",
    "crumbs": [
      "Preface"
    ]
  }
]